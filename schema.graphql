schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}
scalar bigint
scalar jsonb
scalar numeric
scalar timestamptz
scalar uuid
"""
columns and relationships of "accounts"
"""
type accounts {
  access_token: String
  expires_at: bigint
  id: uuid!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String!
  "An object relationship"
  user: users!
  userId: uuid!
}
"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}
"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}
"aggregate avg on columns"
type accounts_avg_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate max on columns"
type accounts_max_fields {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}
"aggregate min on columns"
type accounts_min_fields {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}
"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [accounts!]!
}
"aggregate stddev on columns"
type accounts_stddev_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate stddev_pop on columns"
type accounts_stddev_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate stddev_samp on columns"
type accounts_stddev_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate sum on columns"
type accounts_sum_fields {
  expires_at: bigint
  refresh_token_expires_in: Int
}
"aggregate var_pop on columns"
type accounts_var_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate var_samp on columns"
type accounts_var_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"aggregate variance on columns"
type accounts_variance_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}
"""
columns and relationships of "attachments"
"""
type attachments {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String!
  idCard: String
  idMember: String
  isUpload: Boolean
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"""
aggregated selection of "attachments"
"""
type attachments_aggregate {
  aggregate: attachments_aggregate_fields
  nodes: [attachments!]!
}
"""
aggregate fields of "attachments"
"""
type attachments_aggregate_fields {
  avg: attachments_avg_fields
  count(columns: [attachments_select_column!], distinct: Boolean): Int!
  max: attachments_max_fields
  min: attachments_min_fields
  stddev: attachments_stddev_fields
  stddev_pop: attachments_stddev_pop_fields
  stddev_samp: attachments_stddev_samp_fields
  sum: attachments_sum_fields
  var_pop: attachments_var_pop_fields
  var_samp: attachments_var_samp_fields
  variance: attachments_variance_fields
}
"aggregate avg on columns"
type attachments_avg_fields {
  bytes: Float
  pos: Float
}
"aggregate max on columns"
type attachments_max_fields {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String
  idCard: String
  idMember: String
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"aggregate min on columns"
type attachments_min_fields {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String
  idCard: String
  idMember: String
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"""
response of any mutation on the table "attachments"
"""
type attachments_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [attachments!]!
}
"aggregate stddev on columns"
type attachments_stddev_fields {
  bytes: Float
  pos: Float
}
"aggregate stddev_pop on columns"
type attachments_stddev_pop_fields {
  bytes: Float
  pos: Float
}
"aggregate stddev_samp on columns"
type attachments_stddev_samp_fields {
  bytes: Float
  pos: Float
}
"aggregate sum on columns"
type attachments_sum_fields {
  bytes: numeric
  pos: numeric
}
"aggregate var_pop on columns"
type attachments_var_pop_fields {
  bytes: Float
  pos: Float
}
"aggregate var_samp on columns"
type attachments_var_samp_fields {
  bytes: Float
  pos: Float
}
"aggregate variance on columns"
type attachments_variance_fields {
  bytes: Float
  pos: Float
}
"""
columns and relationships of "boardBackgrounds"
"""
type boardBackgrounds {
  attribution(
    "JSON select path"
    path: String
  ): jsonb
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String!
  tile: Boolean
  topColor: String
  type: String
}
"""
aggregated selection of "boardBackgrounds"
"""
type boardBackgrounds_aggregate {
  aggregate: boardBackgrounds_aggregate_fields
  nodes: [boardBackgrounds!]!
}
"""
aggregate fields of "boardBackgrounds"
"""
type boardBackgrounds_aggregate_fields {
  count(columns: [boardBackgrounds_select_column!], distinct: Boolean): Int!
  max: boardBackgrounds_max_fields
  min: boardBackgrounds_min_fields
}
"aggregate max on columns"
type boardBackgrounds_max_fields {
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String
  topColor: String
  type: String
}
"aggregate min on columns"
type boardBackgrounds_min_fields {
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String
  topColor: String
  type: String
}
"""
response of any mutation on the table "boardBackgrounds"
"""
type boardBackgrounds_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [boardBackgrounds!]!
}
"""
columns and relationships of "boardPrefs"
"""
type boardPrefs {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTile: Boolean
  backgroundTopColor: String
  calendarFeedEnabled: Boolean
  canBeOrg: Boolean
  canBePrivate: Boolean
  canBePublic: Boolean
  canInvite: Boolean
  cardAging: String
  cardCovers: Boolean
  comments: String
  hideVotes: Boolean
  id: String!
  invitations: String
  isTemplate: Boolean
  permissionLevel: String
  selfJoin: Boolean
  voting: String
}
"""
aggregated selection of "boardPrefs"
"""
type boardPrefs_aggregate {
  aggregate: boardPrefs_aggregate_fields
  nodes: [boardPrefs!]!
}
"""
aggregate fields of "boardPrefs"
"""
type boardPrefs_aggregate_fields {
  count(columns: [boardPrefs_select_column!], distinct: Boolean): Int!
  max: boardPrefs_max_fields
  min: boardPrefs_min_fields
}
"aggregate max on columns"
type boardPrefs_max_fields {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTopColor: String
  cardAging: String
  comments: String
  id: String
  invitations: String
  permissionLevel: String
  voting: String
}
"aggregate min on columns"
type boardPrefs_min_fields {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTopColor: String
  cardAging: String
  comments: String
  id: String
  invitations: String
  permissionLevel: String
  voting: String
}
"""
response of any mutation on the table "boardPrefs"
"""
type boardPrefs_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [boardPrefs!]!
}
"""
columns and relationships of "boardStars"
"""
type boardStars {
  id: String!
  idBoard: String
  idMember: String
  pos: numeric
}
"""
aggregated selection of "boardStars"
"""
type boardStars_aggregate {
  aggregate: boardStars_aggregate_fields
  nodes: [boardStars!]!
}
"""
aggregate fields of "boardStars"
"""
type boardStars_aggregate_fields {
  avg: boardStars_avg_fields
  count(columns: [boardStars_select_column!], distinct: Boolean): Int!
  max: boardStars_max_fields
  min: boardStars_min_fields
  stddev: boardStars_stddev_fields
  stddev_pop: boardStars_stddev_pop_fields
  stddev_samp: boardStars_stddev_samp_fields
  sum: boardStars_sum_fields
  var_pop: boardStars_var_pop_fields
  var_samp: boardStars_var_samp_fields
  variance: boardStars_variance_fields
}
"aggregate avg on columns"
type boardStars_avg_fields {
  pos: Float
}
"aggregate max on columns"
type boardStars_max_fields {
  id: String
  idBoard: String
  idMember: String
  pos: numeric
}
"aggregate min on columns"
type boardStars_min_fields {
  id: String
  idBoard: String
  idMember: String
  pos: numeric
}
"""
response of any mutation on the table "boardStars"
"""
type boardStars_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [boardStars!]!
}
"aggregate stddev on columns"
type boardStars_stddev_fields {
  pos: Float
}
"aggregate stddev_pop on columns"
type boardStars_stddev_pop_fields {
  pos: Float
}
"aggregate stddev_samp on columns"
type boardStars_stddev_samp_fields {
  pos: Float
}
"aggregate sum on columns"
type boardStars_sum_fields {
  pos: numeric
}
"aggregate var_pop on columns"
type boardStars_var_pop_fields {
  pos: Float
}
"aggregate var_samp on columns"
type boardStars_var_samp_fields {
  pos: Float
}
"aggregate variance on columns"
type boardStars_variance_fields {
  pos: Float
}
"""
columns and relationships of "boards"
"""
type boards {
  closed: Boolean
  dateClosed: timestamptz
  desc: String
  id: String!
  idMemberCreator: String
  idOrganization: String
  """
  fetch data from the table: "labels"
  """
  labels(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): [labels!]!
  """
  fetch aggregated fields from the table: "labels"
  """
  labels_aggregate(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): labels_aggregate!
  "An array relationship"
  lists(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): [lists!]!
  "An aggregate relationship"
  lists_aggregate(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): lists_aggregate!
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): [memberships!]!
  "An aggregate relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): memberships_aggregate!
  name: String
  pinned: Boolean
  "An object relationship"
  prefs: boardPrefs
  shortUrl: String
  url: String
}
"""
aggregated selection of "boards"
"""
type boards_aggregate {
  aggregate: boards_aggregate_fields
  nodes: [boards!]!
}
"""
aggregate fields of "boards"
"""
type boards_aggregate_fields {
  count(columns: [boards_select_column!], distinct: Boolean): Int!
  max: boards_max_fields
  min: boards_min_fields
}
"aggregate max on columns"
type boards_max_fields {
  dateClosed: timestamptz
  desc: String
  id: String
  idMemberCreator: String
  idOrganization: String
  name: String
  shortUrl: String
  url: String
}
"aggregate min on columns"
type boards_min_fields {
  dateClosed: timestamptz
  desc: String
  id: String
  idMemberCreator: String
  idOrganization: String
  name: String
  shortUrl: String
  url: String
}
"""
response of any mutation on the table "boards"
"""
type boards_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [boards!]!
}
"""
columns and relationships of "cardBadges"
"""
type cardBadges {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  description: Boolean
  due: timestamptz
  dueComplete: Boolean
  fogbugz: String
  id: String!
  location: Boolean
  start: timestamptz
  subscribed: Boolean
  viewingMemberVoted: Boolean
  votes: numeric
}
"""
aggregated selection of "cardBadges"
"""
type cardBadges_aggregate {
  aggregate: cardBadges_aggregate_fields
  nodes: [cardBadges!]!
}
"""
aggregate fields of "cardBadges"
"""
type cardBadges_aggregate_fields {
  avg: cardBadges_avg_fields
  count(columns: [cardBadges_select_column!], distinct: Boolean): Int!
  max: cardBadges_max_fields
  min: cardBadges_min_fields
  stddev: cardBadges_stddev_fields
  stddev_pop: cardBadges_stddev_pop_fields
  stddev_samp: cardBadges_stddev_samp_fields
  sum: cardBadges_sum_fields
  var_pop: cardBadges_var_pop_fields
  var_samp: cardBadges_var_samp_fields
  variance: cardBadges_variance_fields
}
"aggregate avg on columns"
type cardBadges_avg_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate max on columns"
type cardBadges_max_fields {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  due: timestamptz
  fogbugz: String
  id: String
  start: timestamptz
  votes: numeric
}
"aggregate min on columns"
type cardBadges_min_fields {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  due: timestamptz
  fogbugz: String
  id: String
  start: timestamptz
  votes: numeric
}
"""
response of any mutation on the table "cardBadges"
"""
type cardBadges_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cardBadges!]!
}
"aggregate stddev on columns"
type cardBadges_stddev_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate stddev_pop on columns"
type cardBadges_stddev_pop_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate stddev_samp on columns"
type cardBadges_stddev_samp_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate sum on columns"
type cardBadges_sum_fields {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  comments: numeric
  votes: numeric
}
"aggregate var_pop on columns"
type cardBadges_var_pop_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate var_samp on columns"
type cardBadges_var_samp_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"aggregate variance on columns"
type cardBadges_variance_fields {
  attachments: Float
  checkItems: Float
  checkItemsChecked: Float
  comments: Float
  votes: Float
}
"""
columns and relationships of "cardCovers"
"""
type cardCovers {
  brightness: String
  color: String
  id: String!
  idAttachment: String
  size: String
}
"""
aggregated selection of "cardCovers"
"""
type cardCovers_aggregate {
  aggregate: cardCovers_aggregate_fields
  nodes: [cardCovers!]!
}
"""
aggregate fields of "cardCovers"
"""
type cardCovers_aggregate_fields {
  count(columns: [cardCovers_select_column!], distinct: Boolean): Int!
  max: cardCovers_max_fields
  min: cardCovers_min_fields
}
"aggregate max on columns"
type cardCovers_max_fields {
  brightness: String
  color: String
  id: String
  idAttachment: String
  size: String
}
"aggregate min on columns"
type cardCovers_min_fields {
  brightness: String
  color: String
  id: String
  idAttachment: String
  size: String
}
"""
response of any mutation on the table "cardCovers"
"""
type cardCovers_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cardCovers!]!
}
"""
columns and relationships of "cardLabels"
"""
type cardLabels {
  id: String!
  idLabel: String
}
"""
aggregated selection of "cardLabels"
"""
type cardLabels_aggregate {
  aggregate: cardLabels_aggregate_fields
  nodes: [cardLabels!]!
}
"""
aggregate fields of "cardLabels"
"""
type cardLabels_aggregate_fields {
  count(columns: [cardLabels_select_column!], distinct: Boolean): Int!
  max: cardLabels_max_fields
  min: cardLabels_min_fields
}
"aggregate max on columns"
type cardLabels_max_fields {
  id: String
  idLabel: String
}
"aggregate min on columns"
type cardLabels_min_fields {
  id: String
  idLabel: String
}
"""
response of any mutation on the table "cardLabels"
"""
type cardLabels_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cardLabels!]!
}
"""
columns and relationships of "cardMembers"
"""
type cardMembers {
  id: String!
  idMember: String
}
"""
columns and relationships of "cardMembersVoted"
"""
type cardMembersVoted {
  id: String!
  idMember: String
}
"""
aggregated selection of "cardMembersVoted"
"""
type cardMembersVoted_aggregate {
  aggregate: cardMembersVoted_aggregate_fields
  nodes: [cardMembersVoted!]!
}
"""
aggregate fields of "cardMembersVoted"
"""
type cardMembersVoted_aggregate_fields {
  count(columns: [cardMembersVoted_select_column!], distinct: Boolean): Int!
  max: cardMembersVoted_max_fields
  min: cardMembersVoted_min_fields
}
"aggregate max on columns"
type cardMembersVoted_max_fields {
  id: String
  idMember: String
}
"aggregate min on columns"
type cardMembersVoted_min_fields {
  id: String
  idMember: String
}
"""
response of any mutation on the table "cardMembersVoted"
"""
type cardMembersVoted_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cardMembersVoted!]!
}
"""
aggregated selection of "cardMembers"
"""
type cardMembers_aggregate {
  aggregate: cardMembers_aggregate_fields
  nodes: [cardMembers!]!
}
"""
aggregate fields of "cardMembers"
"""
type cardMembers_aggregate_fields {
  count(columns: [cardMembers_select_column!], distinct: Boolean): Int!
  max: cardMembers_max_fields
  min: cardMembers_min_fields
}
"aggregate max on columns"
type cardMembers_max_fields {
  id: String
  idMember: String
}
"aggregate min on columns"
type cardMembers_min_fields {
  id: String
  idMember: String
}
"""
response of any mutation on the table "cardMembers"
"""
type cardMembers_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cardMembers!]!
}
"""
columns and relationships of "cards"
"""
type cards {
  "An array relationship"
  attachments(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): [attachments!]!
  "An aggregate relationship"
  attachments_aggregate(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): attachments_aggregate!
  "An object relationship"
  badges: cardBadges
  """
  fetch data from the table: "checklists"
  """
  checklists(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): [checklists!]!
  """
  fetch aggregated fields from the table: "checklists"
  """
  checklists_aggregate(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): checklists_aggregate!
  closed: Boolean
  "An object relationship"
  cover: cardCovers
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueComplete: Boolean
  dueReminder: numeric
  email: String
  id: String!
  idBoard: String
  idList: String
  idShort: numeric
  isTemplate: Boolean
  "An array relationship"
  labels(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): [cardLabels!]!
  "An aggregate relationship"
  labels_aggregate(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): cardLabels_aggregate!
  manualCoverAttachment: Boolean
  "An array relationship"
  members(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): [cardMembers!]!
  "An array relationship"
  membersVoted(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): [cardMembersVoted!]!
  "An aggregate relationship"
  membersVoted_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): cardMembersVoted_aggregate!
  "An aggregate relationship"
  members_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): cardMembers_aggregate!
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  "An array relationship"
  stickers(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): [stickers!]!
  "An aggregate relationship"
  stickers_aggregate(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): stickers_aggregate!
  subscribed: Boolean
  url: String
}
"""
aggregated selection of "cards"
"""
type cards_aggregate {
  aggregate: cards_aggregate_fields
  nodes: [cards!]!
}
"""
aggregate fields of "cards"
"""
type cards_aggregate_fields {
  avg: cards_avg_fields
  count(columns: [cards_select_column!], distinct: Boolean): Int!
  max: cards_max_fields
  min: cards_min_fields
  stddev: cards_stddev_fields
  stddev_pop: cards_stddev_pop_fields
  stddev_samp: cards_stddev_samp_fields
  sum: cards_sum_fields
  var_pop: cards_var_pop_fields
  var_samp: cards_var_samp_fields
  variance: cards_variance_fields
}
"aggregate avg on columns"
type cards_avg_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate max on columns"
type cards_max_fields {
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueReminder: numeric
  email: String
  id: String
  idBoard: String
  idList: String
  idShort: numeric
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  url: String
}
"aggregate min on columns"
type cards_min_fields {
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueReminder: numeric
  email: String
  id: String
  idBoard: String
  idList: String
  idShort: numeric
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  url: String
}
"""
response of any mutation on the table "cards"
"""
type cards_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [cards!]!
}
"aggregate stddev on columns"
type cards_stddev_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate stddev_pop on columns"
type cards_stddev_pop_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate stddev_samp on columns"
type cards_stddev_samp_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate sum on columns"
type cards_sum_fields {
  dueReminder: numeric
  idShort: numeric
  pos: numeric
}
"aggregate var_pop on columns"
type cards_var_pop_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate var_samp on columns"
type cards_var_samp_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"aggregate variance on columns"
type cards_variance_fields {
  dueReminder: Float
  idShort: Float
  pos: Float
}
"""
columns and relationships of "checkItems"
"""
type checkItems {
  due: timestamptz
  dueReminder: numeric
  id: String!
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"""
aggregated selection of "checkItems"
"""
type checkItems_aggregate {
  aggregate: checkItems_aggregate_fields
  nodes: [checkItems!]!
}
"""
aggregate fields of "checkItems"
"""
type checkItems_aggregate_fields {
  avg: checkItems_avg_fields
  count(columns: [checkItems_select_column!], distinct: Boolean): Int!
  max: checkItems_max_fields
  min: checkItems_min_fields
  stddev: checkItems_stddev_fields
  stddev_pop: checkItems_stddev_pop_fields
  stddev_samp: checkItems_stddev_samp_fields
  sum: checkItems_sum_fields
  var_pop: checkItems_var_pop_fields
  var_samp: checkItems_var_samp_fields
  variance: checkItems_variance_fields
}
"aggregate avg on columns"
type checkItems_avg_fields {
  dueReminder: Float
  pos: Float
}
"aggregate max on columns"
type checkItems_max_fields {
  due: timestamptz
  dueReminder: numeric
  id: String
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"aggregate min on columns"
type checkItems_min_fields {
  due: timestamptz
  dueReminder: numeric
  id: String
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"""
response of any mutation on the table "checkItems"
"""
type checkItems_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [checkItems!]!
}
"aggregate stddev on columns"
type checkItems_stddev_fields {
  dueReminder: Float
  pos: Float
}
"aggregate stddev_pop on columns"
type checkItems_stddev_pop_fields {
  dueReminder: Float
  pos: Float
}
"aggregate stddev_samp on columns"
type checkItems_stddev_samp_fields {
  dueReminder: Float
  pos: Float
}
"aggregate sum on columns"
type checkItems_sum_fields {
  dueReminder: numeric
  pos: numeric
}
"aggregate var_pop on columns"
type checkItems_var_pop_fields {
  dueReminder: Float
  pos: Float
}
"aggregate var_samp on columns"
type checkItems_var_samp_fields {
  dueReminder: Float
  pos: Float
}
"aggregate variance on columns"
type checkItems_variance_fields {
  dueReminder: Float
  pos: Float
}
"""
columns and relationships of "checklists"
"""
type checklists {
  "An array relationship"
  checkItems(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): [checkItems!]!
  "An aggregate relationship"
  checkItems_aggregate(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): checkItems_aggregate!
  id: String!
  idCard: String
  name: String
  pos: numeric
}
"""
aggregated selection of "checklists"
"""
type checklists_aggregate {
  aggregate: checklists_aggregate_fields
  nodes: [checklists!]!
}
"""
aggregate fields of "checklists"
"""
type checklists_aggregate_fields {
  avg: checklists_avg_fields
  count(columns: [checklists_select_column!], distinct: Boolean): Int!
  max: checklists_max_fields
  min: checklists_min_fields
  stddev: checklists_stddev_fields
  stddev_pop: checklists_stddev_pop_fields
  stddev_samp: checklists_stddev_samp_fields
  sum: checklists_sum_fields
  var_pop: checklists_var_pop_fields
  var_samp: checklists_var_samp_fields
  variance: checklists_variance_fields
}
"aggregate avg on columns"
type checklists_avg_fields {
  pos: Float
}
"aggregate max on columns"
type checklists_max_fields {
  id: String
  idCard: String
  name: String
  pos: numeric
}
"aggregate min on columns"
type checklists_min_fields {
  id: String
  idCard: String
  name: String
  pos: numeric
}
"""
response of any mutation on the table "checklists"
"""
type checklists_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [checklists!]!
}
"aggregate stddev on columns"
type checklists_stddev_fields {
  pos: Float
}
"aggregate stddev_pop on columns"
type checklists_stddev_pop_fields {
  pos: Float
}
"aggregate stddev_samp on columns"
type checklists_stddev_samp_fields {
  pos: Float
}
"aggregate sum on columns"
type checklists_sum_fields {
  pos: numeric
}
"aggregate var_pop on columns"
type checklists_var_pop_fields {
  pos: Float
}
"aggregate var_samp on columns"
type checklists_var_samp_fields {
  pos: Float
}
"aggregate variance on columns"
type checklists_variance_fields {
  pos: Float
}
"""
columns and relationships of "customBoardBackgrounds"
"""
type customBoardBackgrounds {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String!
  idMember: String
  tile: Boolean
  topColor: String
  type: String
}
"""
aggregated selection of "customBoardBackgrounds"
"""
type customBoardBackgrounds_aggregate {
  aggregate: customBoardBackgrounds_aggregate_fields
  nodes: [customBoardBackgrounds!]!
}
"""
aggregate fields of "customBoardBackgrounds"
"""
type customBoardBackgrounds_aggregate_fields {
  count(columns: [customBoardBackgrounds_select_column!], distinct: Boolean): Int!
  max: customBoardBackgrounds_max_fields
  min: customBoardBackgrounds_min_fields
}
"aggregate max on columns"
type customBoardBackgrounds_max_fields {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String
  idMember: String
  topColor: String
  type: String
}
"aggregate min on columns"
type customBoardBackgrounds_min_fields {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String
  idMember: String
  topColor: String
  type: String
}
"""
response of any mutation on the table "customBoardBackgrounds"
"""
type customBoardBackgrounds_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [customBoardBackgrounds!]!
}
"""
columns and relationships of "customEmojis"
"""
type customEmojis {
  id: String!
  idMember: String
  name: String
  url: String
}
"""
aggregated selection of "customEmojis"
"""
type customEmojis_aggregate {
  aggregate: customEmojis_aggregate_fields
  nodes: [customEmojis!]!
}
"""
aggregate fields of "customEmojis"
"""
type customEmojis_aggregate_fields {
  count(columns: [customEmojis_select_column!], distinct: Boolean): Int!
  max: customEmojis_max_fields
  min: customEmojis_min_fields
}
"aggregate max on columns"
type customEmojis_max_fields {
  id: String
  idMember: String
  name: String
  url: String
}
"aggregate min on columns"
type customEmojis_min_fields {
  id: String
  idMember: String
  name: String
  url: String
}
"""
response of any mutation on the table "customEmojis"
"""
type customEmojis_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [customEmojis!]!
}
"""
columns and relationships of "customStickers"
"""
type customStickers {
  id: String!
  idMember: String
  url: String
}
"""
aggregated selection of "customStickers"
"""
type customStickers_aggregate {
  aggregate: customStickers_aggregate_fields
  nodes: [customStickers!]!
}
"""
aggregate fields of "customStickers"
"""
type customStickers_aggregate_fields {
  count(columns: [customStickers_select_column!], distinct: Boolean): Int!
  max: customStickers_max_fields
  min: customStickers_min_fields
}
"aggregate max on columns"
type customStickers_max_fields {
  id: String
  idMember: String
  url: String
}
"aggregate min on columns"
type customStickers_min_fields {
  id: String
  idMember: String
  url: String
}
"""
response of any mutation on the table "customStickers"
"""
type customStickers_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [customStickers!]!
}
"""
columns and relationships of "labels"
"""
type labels {
  color: String
  id: String!
  idBoard: String
  name: String
}
"""
aggregated selection of "labels"
"""
type labels_aggregate {
  aggregate: labels_aggregate_fields
  nodes: [labels!]!
}
"""
aggregate fields of "labels"
"""
type labels_aggregate_fields {
  count(columns: [labels_select_column!], distinct: Boolean): Int!
  max: labels_max_fields
  min: labels_min_fields
}
"aggregate max on columns"
type labels_max_fields {
  color: String
  id: String
  idBoard: String
  name: String
}
"aggregate min on columns"
type labels_min_fields {
  color: String
  id: String
  idBoard: String
  name: String
}
"""
response of any mutation on the table "labels"
"""
type labels_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [labels!]!
}
"""
columns and relationships of "lists"
"""
type lists {
  """
  fetch data from the table: "cards"
  """
  cards(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): [cards!]!
  """
  fetch aggregated fields from the table: "cards"
  """
  cards_aggregate(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): cards_aggregate!
  closed: Boolean
  id: String!
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
  subscribed: Boolean
}
"""
aggregated selection of "lists"
"""
type lists_aggregate {
  aggregate: lists_aggregate_fields
  nodes: [lists!]!
}
"""
aggregate fields of "lists"
"""
type lists_aggregate_fields {
  avg: lists_avg_fields
  count(columns: [lists_select_column!], distinct: Boolean): Int!
  max: lists_max_fields
  min: lists_min_fields
  stddev: lists_stddev_fields
  stddev_pop: lists_stddev_pop_fields
  stddev_samp: lists_stddev_samp_fields
  sum: lists_sum_fields
  var_pop: lists_var_pop_fields
  var_samp: lists_var_samp_fields
  variance: lists_variance_fields
}
"aggregate avg on columns"
type lists_avg_fields {
  pos: Float
}
"aggregate max on columns"
type lists_max_fields {
  id: String
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
}
"aggregate min on columns"
type lists_min_fields {
  id: String
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
}
"""
response of any mutation on the table "lists"
"""
type lists_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [lists!]!
}
"aggregate stddev on columns"
type lists_stddev_fields {
  pos: Float
}
"aggregate stddev_pop on columns"
type lists_stddev_pop_fields {
  pos: Float
}
"aggregate stddev_samp on columns"
type lists_stddev_samp_fields {
  pos: Float
}
"aggregate sum on columns"
type lists_sum_fields {
  pos: numeric
}
"aggregate var_pop on columns"
type lists_var_pop_fields {
  pos: Float
}
"aggregate var_samp on columns"
type lists_var_samp_fields {
  pos: Float
}
"aggregate variance on columns"
type lists_variance_fields {
  pos: Float
}
"""
columns and relationships of "memberOrganizations"
"""
type memberOrganizations {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMember: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  premiumFeatures(
    "JSON select path"
    path: String
  ): jsonb
  url: String
  website: String
}
"""
aggregated selection of "memberOrganizations"
"""
type memberOrganizations_aggregate {
  aggregate: memberOrganizations_aggregate_fields
  nodes: [memberOrganizations!]!
}
"""
aggregate fields of "memberOrganizations"
"""
type memberOrganizations_aggregate_fields {
  avg: memberOrganizations_avg_fields
  count(columns: [memberOrganizations_select_column!], distinct: Boolean): Int!
  max: memberOrganizations_max_fields
  min: memberOrganizations_min_fields
  stddev: memberOrganizations_stddev_fields
  stddev_pop: memberOrganizations_stddev_pop_fields
  stddev_samp: memberOrganizations_stddev_samp_fields
  sum: memberOrganizations_sum_fields
  var_pop: memberOrganizations_var_pop_fields
  var_samp: memberOrganizations_var_samp_fields
  variance: memberOrganizations_variance_fields
}
"aggregate avg on columns"
type memberOrganizations_avg_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate max on columns"
type memberOrganizations_max_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMember: String
  idMemberCreator: String
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  url: String
  website: String
}
"aggregate min on columns"
type memberOrganizations_min_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMember: String
  idMemberCreator: String
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  url: String
  website: String
}
"aggregate stddev on columns"
type memberOrganizations_stddev_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate stddev_pop on columns"
type memberOrganizations_stddev_pop_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate stddev_samp on columns"
type memberOrganizations_stddev_samp_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate sum on columns"
type memberOrganizations_sum_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  membersCount: numeric
}
"aggregate var_pop on columns"
type memberOrganizations_var_pop_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate var_samp on columns"
type memberOrganizations_var_samp_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate variance on columns"
type memberOrganizations_variance_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"""
columns and relationships of "memberPrefs"
"""
type memberPrefs {
  colorBlind: Boolean
  id: String!
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
  sendSummaries: Boolean
}
"""
aggregated selection of "memberPrefs"
"""
type memberPrefs_aggregate {
  aggregate: memberPrefs_aggregate_fields
  nodes: [memberPrefs!]!
}
"""
aggregate fields of "memberPrefs"
"""
type memberPrefs_aggregate_fields {
  avg: memberPrefs_avg_fields
  count(columns: [memberPrefs_select_column!], distinct: Boolean): Int!
  max: memberPrefs_max_fields
  min: memberPrefs_min_fields
  stddev: memberPrefs_stddev_fields
  stddev_pop: memberPrefs_stddev_pop_fields
  stddev_samp: memberPrefs_stddev_samp_fields
  sum: memberPrefs_sum_fields
  var_pop: memberPrefs_var_pop_fields
  var_samp: memberPrefs_var_samp_fields
  variance: memberPrefs_variance_fields
}
"aggregate avg on columns"
type memberPrefs_avg_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate max on columns"
type memberPrefs_max_fields {
  id: String
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
}
"aggregate min on columns"
type memberPrefs_min_fields {
  id: String
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
}
"""
response of any mutation on the table "memberPrefs"
"""
type memberPrefs_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [memberPrefs!]!
}
"aggregate stddev on columns"
type memberPrefs_stddev_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate stddev_pop on columns"
type memberPrefs_stddev_pop_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate stddev_samp on columns"
type memberPrefs_stddev_samp_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate sum on columns"
type memberPrefs_sum_fields {
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
}
"aggregate var_pop on columns"
type memberPrefs_var_pop_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate var_samp on columns"
type memberPrefs_var_samp_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"aggregate variance on columns"
type memberPrefs_variance_fields {
  minutesBeforeDeadlineToNotify: Float
  minutesBetweenSummaries: Float
}
"""
columns and relationships of "members"
"""
type members {
  activityBlocked: Boolean
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  "An array relationship"
  boardStars(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): [boardStars!]!
  "An aggregate relationship"
  boardStars_aggregate(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): boardStars_aggregate!
  "An array relationship"
  boards(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): [memberships!]!
  "An aggregate relationship"
  boards_aggregate(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): memberships_aggregate!
  confirmed: Boolean
  credentialsRemovedCount: numeric
  "An array relationship"
  customBoardBackgrounds(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): [customBoardBackgrounds!]!
  "An aggregate relationship"
  customBoardBackgrounds_aggregate(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): customBoardBackgrounds_aggregate!
  "An array relationship"
  customEmojis(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): [customEmojis!]!
  "An aggregate relationship"
  customEmojis_aggregate(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): customEmojis_aggregate!
  "An array relationship"
  customStickers(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): [customStickers!]!
  "An aggregate relationship"
  customStickers_aggregate(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): customStickers_aggregate!
  email: String
  fullName: String
  gravatarHash: String
  id: String!
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  loginTypes(
    "JSON select path"
    path: String
  ): jsonb
  memberType: String
  nonPublicAvailable: Boolean
  oneTimeMessagesDismissed(
    "JSON select path"
    path: String
  ): jsonb
  "An array relationship"
  organizations(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): [memberOrganizations!]!
  "An aggregate relationship"
  organizations_aggregate(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): memberOrganizations_aggregate!
  "An object relationship"
  prefs: memberPrefs
  premiumFeatures(
    "JSON select path"
    path: String
  ): jsonb
  "An array relationship"
  savedSearches(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): [savedSearches!]!
  "An aggregate relationship"
  savedSearches_aggregate(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): savedSearches_aggregate!
  status: String
  "An array relationship"
  tokens(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): [tokens!]!
  "An aggregate relationship"
  tokens_aggregate(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): tokens_aggregate!
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
"""
aggregated selection of "members"
"""
type members_aggregate {
  aggregate: members_aggregate_fields
  nodes: [members!]!
}
"""
aggregate fields of "members"
"""
type members_aggregate_fields {
  avg: members_avg_fields
  count(columns: [members_select_column!], distinct: Boolean): Int!
  max: members_max_fields
  min: members_min_fields
  stddev: members_stddev_fields
  stddev_pop: members_stddev_pop_fields
  stddev_samp: members_stddev_samp_fields
  sum: members_sum_fields
  var_pop: members_var_pop_fields
  var_samp: members_var_samp_fields
  variance: members_variance_fields
}
"aggregate avg on columns"
type members_avg_fields {
  credentialsRemovedCount: Float
}
"aggregate max on columns"
type members_max_fields {
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  credentialsRemovedCount: numeric
  email: String
  fullName: String
  gravatarHash: String
  id: String
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  memberType: String
  status: String
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
"aggregate min on columns"
type members_min_fields {
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  credentialsRemovedCount: numeric
  email: String
  fullName: String
  gravatarHash: String
  id: String
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  memberType: String
  status: String
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
"""
response of any mutation on the table "members"
"""
type members_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [members!]!
}
"aggregate stddev on columns"
type members_stddev_fields {
  credentialsRemovedCount: Float
}
"aggregate stddev_pop on columns"
type members_stddev_pop_fields {
  credentialsRemovedCount: Float
}
"aggregate stddev_samp on columns"
type members_stddev_samp_fields {
  credentialsRemovedCount: Float
}
"aggregate sum on columns"
type members_sum_fields {
  credentialsRemovedCount: numeric
}
"aggregate var_pop on columns"
type members_var_pop_fields {
  credentialsRemovedCount: Float
}
"aggregate var_samp on columns"
type members_var_samp_fields {
  credentialsRemovedCount: Float
}
"aggregate variance on columns"
type members_variance_fields {
  credentialsRemovedCount: Float
}
"""
columns and relationships of "memberships"
"""
type memberships {
  deactivated: Boolean
  id: String!
  idBoard: String
  idMember: String
  memberType: String
  unconfirmed: Boolean
}
"""
aggregated selection of "memberships"
"""
type memberships_aggregate {
  aggregate: memberships_aggregate_fields
  nodes: [memberships!]!
}
"""
aggregate fields of "memberships"
"""
type memberships_aggregate_fields {
  count(columns: [memberships_select_column!], distinct: Boolean): Int!
  max: memberships_max_fields
  min: memberships_min_fields
}
"aggregate max on columns"
type memberships_max_fields {
  id: String
  idBoard: String
  idMember: String
  memberType: String
}
"aggregate min on columns"
type memberships_min_fields {
  id: String
  idBoard: String
  idMember: String
  memberType: String
}
"""
response of any mutation on the table "memberships"
"""
type memberships_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [memberships!]!
}
"mutation root"
type mutation_root {
  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    "filter the rows which have to be deleted"
    where: accounts_bool_exp!
  ): accounts_mutation_response
  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: uuid!): accounts
  """
  delete data from the table: "attachments"
  """
  delete_attachments(
    "filter the rows which have to be deleted"
    where: attachments_bool_exp!
  ): attachments_mutation_response
  """
  delete single row from the table: "attachments"
  """
  delete_attachments_by_pk(id: String!): attachments
  """
  delete data from the table: "boardBackgrounds"
  """
  delete_boardBackgrounds(
    "filter the rows which have to be deleted"
    where: boardBackgrounds_bool_exp!
  ): boardBackgrounds_mutation_response
  """
  delete single row from the table: "boardBackgrounds"
  """
  delete_boardBackgrounds_by_pk(id: String!): boardBackgrounds
  """
  delete data from the table: "boardPrefs"
  """
  delete_boardPrefs(
    "filter the rows which have to be deleted"
    where: boardPrefs_bool_exp!
  ): boardPrefs_mutation_response
  """
  delete single row from the table: "boardPrefs"
  """
  delete_boardPrefs_by_pk(id: String!): boardPrefs
  """
  delete data from the table: "boardStars"
  """
  delete_boardStars(
    "filter the rows which have to be deleted"
    where: boardStars_bool_exp!
  ): boardStars_mutation_response
  """
  delete single row from the table: "boardStars"
  """
  delete_boardStars_by_pk(id: String!): boardStars
  """
  delete data from the table: "boards"
  """
  delete_boards(
    "filter the rows which have to be deleted"
    where: boards_bool_exp!
  ): boards_mutation_response
  """
  delete single row from the table: "boards"
  """
  delete_boards_by_pk(id: String!): boards
  """
  delete data from the table: "cardBadges"
  """
  delete_cardBadges(
    "filter the rows which have to be deleted"
    where: cardBadges_bool_exp!
  ): cardBadges_mutation_response
  """
  delete single row from the table: "cardBadges"
  """
  delete_cardBadges_by_pk(id: String!): cardBadges
  """
  delete data from the table: "cardCovers"
  """
  delete_cardCovers(
    "filter the rows which have to be deleted"
    where: cardCovers_bool_exp!
  ): cardCovers_mutation_response
  """
  delete single row from the table: "cardCovers"
  """
  delete_cardCovers_by_pk(id: String!): cardCovers
  """
  delete data from the table: "cardLabels"
  """
  delete_cardLabels(
    "filter the rows which have to be deleted"
    where: cardLabels_bool_exp!
  ): cardLabels_mutation_response
  """
  delete single row from the table: "cardLabels"
  """
  delete_cardLabels_by_pk(id: String!): cardLabels
  """
  delete data from the table: "cardMembers"
  """
  delete_cardMembers(
    "filter the rows which have to be deleted"
    where: cardMembers_bool_exp!
  ): cardMembers_mutation_response
  """
  delete data from the table: "cardMembersVoted"
  """
  delete_cardMembersVoted(
    "filter the rows which have to be deleted"
    where: cardMembersVoted_bool_exp!
  ): cardMembersVoted_mutation_response
  """
  delete single row from the table: "cardMembersVoted"
  """
  delete_cardMembersVoted_by_pk(id: String!): cardMembersVoted
  """
  delete single row from the table: "cardMembers"
  """
  delete_cardMembers_by_pk(id: String!): cardMembers
  """
  delete data from the table: "cards"
  """
  delete_cards(
    "filter the rows which have to be deleted"
    where: cards_bool_exp!
  ): cards_mutation_response
  """
  delete single row from the table: "cards"
  """
  delete_cards_by_pk(id: String!): cards
  """
  delete data from the table: "checkItems"
  """
  delete_checkItems(
    "filter the rows which have to be deleted"
    where: checkItems_bool_exp!
  ): checkItems_mutation_response
  """
  delete single row from the table: "checkItems"
  """
  delete_checkItems_by_pk(id: String!): checkItems
  """
  delete data from the table: "checklists"
  """
  delete_checklists(
    "filter the rows which have to be deleted"
    where: checklists_bool_exp!
  ): checklists_mutation_response
  """
  delete single row from the table: "checklists"
  """
  delete_checklists_by_pk(id: String!): checklists
  """
  delete data from the table: "customBoardBackgrounds"
  """
  delete_customBoardBackgrounds(
    "filter the rows which have to be deleted"
    where: customBoardBackgrounds_bool_exp!
  ): customBoardBackgrounds_mutation_response
  """
  delete single row from the table: "customBoardBackgrounds"
  """
  delete_customBoardBackgrounds_by_pk(id: String!): customBoardBackgrounds
  """
  delete data from the table: "customEmojis"
  """
  delete_customEmojis(
    "filter the rows which have to be deleted"
    where: customEmojis_bool_exp!
  ): customEmojis_mutation_response
  """
  delete single row from the table: "customEmojis"
  """
  delete_customEmojis_by_pk(id: String!): customEmojis
  """
  delete data from the table: "customStickers"
  """
  delete_customStickers(
    "filter the rows which have to be deleted"
    where: customStickers_bool_exp!
  ): customStickers_mutation_response
  """
  delete single row from the table: "customStickers"
  """
  delete_customStickers_by_pk(id: String!): customStickers
  """
  delete data from the table: "labels"
  """
  delete_labels(
    "filter the rows which have to be deleted"
    where: labels_bool_exp!
  ): labels_mutation_response
  """
  delete single row from the table: "labels"
  """
  delete_labels_by_pk(id: String!): labels
  """
  delete data from the table: "lists"
  """
  delete_lists(
    "filter the rows which have to be deleted"
    where: lists_bool_exp!
  ): lists_mutation_response
  """
  delete single row from the table: "lists"
  """
  delete_lists_by_pk(id: String!): lists
  """
  delete data from the table: "memberPrefs"
  """
  delete_memberPrefs(
    "filter the rows which have to be deleted"
    where: memberPrefs_bool_exp!
  ): memberPrefs_mutation_response
  """
  delete single row from the table: "memberPrefs"
  """
  delete_memberPrefs_by_pk(id: String!): memberPrefs
  """
  delete data from the table: "members"
  """
  delete_members(
    "filter the rows which have to be deleted"
    where: members_bool_exp!
  ): members_mutation_response
  """
  delete single row from the table: "members"
  """
  delete_members_by_pk(id: String!): members
  """
  delete data from the table: "memberships"
  """
  delete_memberships(
    "filter the rows which have to be deleted"
    where: memberships_bool_exp!
  ): memberships_mutation_response
  """
  delete single row from the table: "memberships"
  """
  delete_memberships_by_pk(id: String!): memberships
  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    "filter the rows which have to be deleted"
    where: notifications_bool_exp!
  ): notifications_mutation_response
  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: String!): notifications
  """
  delete data from the table: "organizationPrefs"
  """
  delete_organizationPrefs(
    "filter the rows which have to be deleted"
    where: organizationPrefs_bool_exp!
  ): organizationPrefs_mutation_response
  """
  delete single row from the table: "organizationPrefs"
  """
  delete_organizationPrefs_by_pk(id: String!): organizationPrefs
  """
  delete data from the table: "organizations"
  """
  delete_organizations(
    "filter the rows which have to be deleted"
    where: organizations_bool_exp!
  ): organizations_mutation_response
  """
  delete single row from the table: "organizations"
  """
  delete_organizations_by_pk(id: String!): organizations
  """
  delete data from the table: "savedSearches"
  """
  delete_savedSearches(
    "filter the rows which have to be deleted"
    where: savedSearches_bool_exp!
  ): savedSearches_mutation_response
  """
  delete single row from the table: "savedSearches"
  """
  delete_savedSearches_by_pk(id: String!): savedSearches
  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    "filter the rows which have to be deleted"
    where: sessions_bool_exp!
  ): sessions_mutation_response
  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(id: uuid!): sessions
  """
  delete data from the table: "stickers"
  """
  delete_stickers(
    "filter the rows which have to be deleted"
    where: stickers_bool_exp!
  ): stickers_mutation_response
  """
  delete single row from the table: "stickers"
  """
  delete_stickers_by_pk(id: String!): stickers
  """
  delete data from the table: "tokenPermissions"
  """
  delete_tokenPermissions(
    "filter the rows which have to be deleted"
    where: tokenPermissions_bool_exp!
  ): tokenPermissions_mutation_response
  """
  delete single row from the table: "tokenPermissions"
  """
  delete_tokenPermissions_by_pk(id: String!): tokenPermissions
  """
  delete data from the table: "tokens"
  """
  delete_tokens(
    "filter the rows which have to be deleted"
    where: tokens_bool_exp!
  ): tokens_mutation_response
  """
  delete single row from the table: "tokens"
  """
  delete_tokens_by_pk(id: String!): tokens
  """
  delete data from the table: "users"
  """
  delete_users(
    "filter the rows which have to be deleted"
    where: users_bool_exp!
  ): users_mutation_response
  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users
  """
  delete data from the table: "verification_tokens"
  """
  delete_verification_tokens(
    "filter the rows which have to be deleted"
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response
  """
  delete single row from the table: "verification_tokens"
  """
  delete_verification_tokens_by_pk(token: String!): verification_tokens
  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    "the rows to be inserted"
    objects: [accounts_insert_input!]!,
    "upsert condition"
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response
  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    "the row to be inserted"
    object: accounts_insert_input!,
    "upsert condition"
    on_conflict: accounts_on_conflict
  ): accounts
  """
  insert data into the table: "attachments"
  """
  insert_attachments(
    "the rows to be inserted"
    objects: [attachments_insert_input!]!,
    "upsert condition"
    on_conflict: attachments_on_conflict
  ): attachments_mutation_response
  """
  insert a single row into the table: "attachments"
  """
  insert_attachments_one(
    "the row to be inserted"
    object: attachments_insert_input!,
    "upsert condition"
    on_conflict: attachments_on_conflict
  ): attachments
  """
  insert data into the table: "boardBackgrounds"
  """
  insert_boardBackgrounds(
    "the rows to be inserted"
    objects: [boardBackgrounds_insert_input!]!,
    "upsert condition"
    on_conflict: boardBackgrounds_on_conflict
  ): boardBackgrounds_mutation_response
  """
  insert a single row into the table: "boardBackgrounds"
  """
  insert_boardBackgrounds_one(
    "the row to be inserted"
    object: boardBackgrounds_insert_input!,
    "upsert condition"
    on_conflict: boardBackgrounds_on_conflict
  ): boardBackgrounds
  """
  insert data into the table: "boardPrefs"
  """
  insert_boardPrefs(
    "the rows to be inserted"
    objects: [boardPrefs_insert_input!]!,
    "upsert condition"
    on_conflict: boardPrefs_on_conflict
  ): boardPrefs_mutation_response
  """
  insert a single row into the table: "boardPrefs"
  """
  insert_boardPrefs_one(
    "the row to be inserted"
    object: boardPrefs_insert_input!,
    "upsert condition"
    on_conflict: boardPrefs_on_conflict
  ): boardPrefs
  """
  insert data into the table: "boardStars"
  """
  insert_boardStars(
    "the rows to be inserted"
    objects: [boardStars_insert_input!]!,
    "upsert condition"
    on_conflict: boardStars_on_conflict
  ): boardStars_mutation_response
  """
  insert a single row into the table: "boardStars"
  """
  insert_boardStars_one(
    "the row to be inserted"
    object: boardStars_insert_input!,
    "upsert condition"
    on_conflict: boardStars_on_conflict
  ): boardStars
  """
  insert data into the table: "boards"
  """
  insert_boards(
    "the rows to be inserted"
    objects: [boards_insert_input!]!,
    "upsert condition"
    on_conflict: boards_on_conflict
  ): boards_mutation_response
  """
  insert a single row into the table: "boards"
  """
  insert_boards_one(
    "the row to be inserted"
    object: boards_insert_input!,
    "upsert condition"
    on_conflict: boards_on_conflict
  ): boards
  """
  insert data into the table: "cardBadges"
  """
  insert_cardBadges(
    "the rows to be inserted"
    objects: [cardBadges_insert_input!]!,
    "upsert condition"
    on_conflict: cardBadges_on_conflict
  ): cardBadges_mutation_response
  """
  insert a single row into the table: "cardBadges"
  """
  insert_cardBadges_one(
    "the row to be inserted"
    object: cardBadges_insert_input!,
    "upsert condition"
    on_conflict: cardBadges_on_conflict
  ): cardBadges
  """
  insert data into the table: "cardCovers"
  """
  insert_cardCovers(
    "the rows to be inserted"
    objects: [cardCovers_insert_input!]!,
    "upsert condition"
    on_conflict: cardCovers_on_conflict
  ): cardCovers_mutation_response
  """
  insert a single row into the table: "cardCovers"
  """
  insert_cardCovers_one(
    "the row to be inserted"
    object: cardCovers_insert_input!,
    "upsert condition"
    on_conflict: cardCovers_on_conflict
  ): cardCovers
  """
  insert data into the table: "cardLabels"
  """
  insert_cardLabels(
    "the rows to be inserted"
    objects: [cardLabels_insert_input!]!,
    "upsert condition"
    on_conflict: cardLabels_on_conflict
  ): cardLabels_mutation_response
  """
  insert a single row into the table: "cardLabels"
  """
  insert_cardLabels_one(
    "the row to be inserted"
    object: cardLabels_insert_input!,
    "upsert condition"
    on_conflict: cardLabels_on_conflict
  ): cardLabels
  """
  insert data into the table: "cardMembers"
  """
  insert_cardMembers(
    "the rows to be inserted"
    objects: [cardMembers_insert_input!]!,
    "upsert condition"
    on_conflict: cardMembers_on_conflict
  ): cardMembers_mutation_response
  """
  insert data into the table: "cardMembersVoted"
  """
  insert_cardMembersVoted(
    "the rows to be inserted"
    objects: [cardMembersVoted_insert_input!]!,
    "upsert condition"
    on_conflict: cardMembersVoted_on_conflict
  ): cardMembersVoted_mutation_response
  """
  insert a single row into the table: "cardMembersVoted"
  """
  insert_cardMembersVoted_one(
    "the row to be inserted"
    object: cardMembersVoted_insert_input!,
    "upsert condition"
    on_conflict: cardMembersVoted_on_conflict
  ): cardMembersVoted
  """
  insert a single row into the table: "cardMembers"
  """
  insert_cardMembers_one(
    "the row to be inserted"
    object: cardMembers_insert_input!,
    "upsert condition"
    on_conflict: cardMembers_on_conflict
  ): cardMembers
  """
  insert data into the table: "cards"
  """
  insert_cards(
    "the rows to be inserted"
    objects: [cards_insert_input!]!,
    "upsert condition"
    on_conflict: cards_on_conflict
  ): cards_mutation_response
  """
  insert a single row into the table: "cards"
  """
  insert_cards_one(
    "the row to be inserted"
    object: cards_insert_input!,
    "upsert condition"
    on_conflict: cards_on_conflict
  ): cards
  """
  insert data into the table: "checkItems"
  """
  insert_checkItems(
    "the rows to be inserted"
    objects: [checkItems_insert_input!]!,
    "upsert condition"
    on_conflict: checkItems_on_conflict
  ): checkItems_mutation_response
  """
  insert a single row into the table: "checkItems"
  """
  insert_checkItems_one(
    "the row to be inserted"
    object: checkItems_insert_input!,
    "upsert condition"
    on_conflict: checkItems_on_conflict
  ): checkItems
  """
  insert data into the table: "checklists"
  """
  insert_checklists(
    "the rows to be inserted"
    objects: [checklists_insert_input!]!,
    "upsert condition"
    on_conflict: checklists_on_conflict
  ): checklists_mutation_response
  """
  insert a single row into the table: "checklists"
  """
  insert_checklists_one(
    "the row to be inserted"
    object: checklists_insert_input!,
    "upsert condition"
    on_conflict: checklists_on_conflict
  ): checklists
  """
  insert data into the table: "customBoardBackgrounds"
  """
  insert_customBoardBackgrounds(
    "the rows to be inserted"
    objects: [customBoardBackgrounds_insert_input!]!,
    "upsert condition"
    on_conflict: customBoardBackgrounds_on_conflict
  ): customBoardBackgrounds_mutation_response
  """
  insert a single row into the table: "customBoardBackgrounds"
  """
  insert_customBoardBackgrounds_one(
    "the row to be inserted"
    object: customBoardBackgrounds_insert_input!,
    "upsert condition"
    on_conflict: customBoardBackgrounds_on_conflict
  ): customBoardBackgrounds
  """
  insert data into the table: "customEmojis"
  """
  insert_customEmojis(
    "the rows to be inserted"
    objects: [customEmojis_insert_input!]!,
    "upsert condition"
    on_conflict: customEmojis_on_conflict
  ): customEmojis_mutation_response
  """
  insert a single row into the table: "customEmojis"
  """
  insert_customEmojis_one(
    "the row to be inserted"
    object: customEmojis_insert_input!,
    "upsert condition"
    on_conflict: customEmojis_on_conflict
  ): customEmojis
  """
  insert data into the table: "customStickers"
  """
  insert_customStickers(
    "the rows to be inserted"
    objects: [customStickers_insert_input!]!,
    "upsert condition"
    on_conflict: customStickers_on_conflict
  ): customStickers_mutation_response
  """
  insert a single row into the table: "customStickers"
  """
  insert_customStickers_one(
    "the row to be inserted"
    object: customStickers_insert_input!,
    "upsert condition"
    on_conflict: customStickers_on_conflict
  ): customStickers
  """
  insert data into the table: "labels"
  """
  insert_labels(
    "the rows to be inserted"
    objects: [labels_insert_input!]!,
    "upsert condition"
    on_conflict: labels_on_conflict
  ): labels_mutation_response
  """
  insert a single row into the table: "labels"
  """
  insert_labels_one(
    "the row to be inserted"
    object: labels_insert_input!,
    "upsert condition"
    on_conflict: labels_on_conflict
  ): labels
  """
  insert data into the table: "lists"
  """
  insert_lists(
    "the rows to be inserted"
    objects: [lists_insert_input!]!,
    "upsert condition"
    on_conflict: lists_on_conflict
  ): lists_mutation_response
  """
  insert a single row into the table: "lists"
  """
  insert_lists_one(
    "the row to be inserted"
    object: lists_insert_input!,
    "upsert condition"
    on_conflict: lists_on_conflict
  ): lists
  """
  insert data into the table: "memberPrefs"
  """
  insert_memberPrefs(
    "the rows to be inserted"
    objects: [memberPrefs_insert_input!]!,
    "upsert condition"
    on_conflict: memberPrefs_on_conflict
  ): memberPrefs_mutation_response
  """
  insert a single row into the table: "memberPrefs"
  """
  insert_memberPrefs_one(
    "the row to be inserted"
    object: memberPrefs_insert_input!,
    "upsert condition"
    on_conflict: memberPrefs_on_conflict
  ): memberPrefs
  """
  insert data into the table: "members"
  """
  insert_members(
    "the rows to be inserted"
    objects: [members_insert_input!]!,
    "upsert condition"
    on_conflict: members_on_conflict
  ): members_mutation_response
  """
  insert a single row into the table: "members"
  """
  insert_members_one(
    "the row to be inserted"
    object: members_insert_input!,
    "upsert condition"
    on_conflict: members_on_conflict
  ): members
  """
  insert data into the table: "memberships"
  """
  insert_memberships(
    "the rows to be inserted"
    objects: [memberships_insert_input!]!,
    "upsert condition"
    on_conflict: memberships_on_conflict
  ): memberships_mutation_response
  """
  insert a single row into the table: "memberships"
  """
  insert_memberships_one(
    "the row to be inserted"
    object: memberships_insert_input!,
    "upsert condition"
    on_conflict: memberships_on_conflict
  ): memberships
  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    "the rows to be inserted"
    objects: [notifications_insert_input!]!,
    "upsert condition"
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response
  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    "the row to be inserted"
    object: notifications_insert_input!,
    "upsert condition"
    on_conflict: notifications_on_conflict
  ): notifications
  """
  insert data into the table: "organizationPrefs"
  """
  insert_organizationPrefs(
    "the rows to be inserted"
    objects: [organizationPrefs_insert_input!]!,
    "upsert condition"
    on_conflict: organizationPrefs_on_conflict
  ): organizationPrefs_mutation_response
  """
  insert a single row into the table: "organizationPrefs"
  """
  insert_organizationPrefs_one(
    "the row to be inserted"
    object: organizationPrefs_insert_input!,
    "upsert condition"
    on_conflict: organizationPrefs_on_conflict
  ): organizationPrefs
  """
  insert data into the table: "organizations"
  """
  insert_organizations(
    "the rows to be inserted"
    objects: [organizations_insert_input!]!,
    "upsert condition"
    on_conflict: organizations_on_conflict
  ): organizations_mutation_response
  """
  insert a single row into the table: "organizations"
  """
  insert_organizations_one(
    "the row to be inserted"
    object: organizations_insert_input!,
    "upsert condition"
    on_conflict: organizations_on_conflict
  ): organizations
  """
  insert data into the table: "savedSearches"
  """
  insert_savedSearches(
    "the rows to be inserted"
    objects: [savedSearches_insert_input!]!,
    "upsert condition"
    on_conflict: savedSearches_on_conflict
  ): savedSearches_mutation_response
  """
  insert a single row into the table: "savedSearches"
  """
  insert_savedSearches_one(
    "the row to be inserted"
    object: savedSearches_insert_input!,
    "upsert condition"
    on_conflict: savedSearches_on_conflict
  ): savedSearches
  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    "the rows to be inserted"
    objects: [sessions_insert_input!]!,
    "upsert condition"
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response
  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    "the row to be inserted"
    object: sessions_insert_input!,
    "upsert condition"
    on_conflict: sessions_on_conflict
  ): sessions
  """
  insert data into the table: "stickers"
  """
  insert_stickers(
    "the rows to be inserted"
    objects: [stickers_insert_input!]!,
    "upsert condition"
    on_conflict: stickers_on_conflict
  ): stickers_mutation_response
  """
  insert a single row into the table: "stickers"
  """
  insert_stickers_one(
    "the row to be inserted"
    object: stickers_insert_input!,
    "upsert condition"
    on_conflict: stickers_on_conflict
  ): stickers
  """
  insert data into the table: "tokenPermissions"
  """
  insert_tokenPermissions(
    "the rows to be inserted"
    objects: [tokenPermissions_insert_input!]!,
    "upsert condition"
    on_conflict: tokenPermissions_on_conflict
  ): tokenPermissions_mutation_response
  """
  insert a single row into the table: "tokenPermissions"
  """
  insert_tokenPermissions_one(
    "the row to be inserted"
    object: tokenPermissions_insert_input!,
    "upsert condition"
    on_conflict: tokenPermissions_on_conflict
  ): tokenPermissions
  """
  insert data into the table: "tokens"
  """
  insert_tokens(
    "the rows to be inserted"
    objects: [tokens_insert_input!]!,
    "upsert condition"
    on_conflict: tokens_on_conflict
  ): tokens_mutation_response
  """
  insert a single row into the table: "tokens"
  """
  insert_tokens_one(
    "the row to be inserted"
    object: tokens_insert_input!,
    "upsert condition"
    on_conflict: tokens_on_conflict
  ): tokens
  """
  insert data into the table: "users"
  """
  insert_users(
    "the rows to be inserted"
    objects: [users_insert_input!]!,
    "upsert condition"
    on_conflict: users_on_conflict
  ): users_mutation_response
  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    "the row to be inserted"
    object: users_insert_input!,
    "upsert condition"
    on_conflict: users_on_conflict
  ): users
  """
  insert data into the table: "verification_tokens"
  """
  insert_verification_tokens(
    "the rows to be inserted"
    objects: [verification_tokens_insert_input!]!,
    "upsert condition"
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens_mutation_response
  """
  insert a single row into the table: "verification_tokens"
  """
  insert_verification_tokens_one(
    "the row to be inserted"
    object: verification_tokens_insert_input!,
    "upsert condition"
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens
  """
  update data of the table: "accounts"
  """
  update_accounts(
    "increments the numeric columns with given value of the filtered values"
    _inc: accounts_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: accounts_set_input,
    "filter the rows which have to be updated"
    where: accounts_bool_exp!
  ): accounts_mutation_response
  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: accounts_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: accounts_set_input,pk_columns: accounts_pk_columns_input!  ): accounts
  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    "updates to execute, in order"
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]
  """
  update data of the table: "attachments"
  """
  update_attachments(
    "increments the numeric columns with given value of the filtered values"
    _inc: attachments_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: attachments_set_input,
    "filter the rows which have to be updated"
    where: attachments_bool_exp!
  ): attachments_mutation_response
  """
  update single row of the table: "attachments"
  """
  update_attachments_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: attachments_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: attachments_set_input,pk_columns: attachments_pk_columns_input!  ): attachments
  """
  update multiples rows of table: "attachments"
  """
  update_attachments_many(
    "updates to execute, in order"
    updates: [attachments_updates!]!
  ): [attachments_mutation_response]
  """
  update data of the table: "boardBackgrounds"
  """
  update_boardBackgrounds(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: boardBackgrounds_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: boardBackgrounds_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: boardBackgrounds_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: boardBackgrounds_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: boardBackgrounds_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: boardBackgrounds_set_input,
    "filter the rows which have to be updated"
    where: boardBackgrounds_bool_exp!
  ): boardBackgrounds_mutation_response
  """
  update single row of the table: "boardBackgrounds"
  """
  update_boardBackgrounds_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: boardBackgrounds_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: boardBackgrounds_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: boardBackgrounds_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: boardBackgrounds_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: boardBackgrounds_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: boardBackgrounds_set_input,pk_columns: boardBackgrounds_pk_columns_input!  ): boardBackgrounds
  """
  update multiples rows of table: "boardBackgrounds"
  """
  update_boardBackgrounds_many(
    "updates to execute, in order"
    updates: [boardBackgrounds_updates!]!
  ): [boardBackgrounds_mutation_response]
  """
  update data of the table: "boardPrefs"
  """
  update_boardPrefs(
    "sets the columns of the filtered rows to the given values"
    _set: boardPrefs_set_input,
    "filter the rows which have to be updated"
    where: boardPrefs_bool_exp!
  ): boardPrefs_mutation_response
  """
  update single row of the table: "boardPrefs"
  """
  update_boardPrefs_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: boardPrefs_set_input,pk_columns: boardPrefs_pk_columns_input!  ): boardPrefs
  """
  update multiples rows of table: "boardPrefs"
  """
  update_boardPrefs_many(
    "updates to execute, in order"
    updates: [boardPrefs_updates!]!
  ): [boardPrefs_mutation_response]
  """
  update data of the table: "boardStars"
  """
  update_boardStars(
    "increments the numeric columns with given value of the filtered values"
    _inc: boardStars_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: boardStars_set_input,
    "filter the rows which have to be updated"
    where: boardStars_bool_exp!
  ): boardStars_mutation_response
  """
  update single row of the table: "boardStars"
  """
  update_boardStars_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: boardStars_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: boardStars_set_input,pk_columns: boardStars_pk_columns_input!  ): boardStars
  """
  update multiples rows of table: "boardStars"
  """
  update_boardStars_many(
    "updates to execute, in order"
    updates: [boardStars_updates!]!
  ): [boardStars_mutation_response]
  """
  update data of the table: "boards"
  """
  update_boards(
    "sets the columns of the filtered rows to the given values"
    _set: boards_set_input,
    "filter the rows which have to be updated"
    where: boards_bool_exp!
  ): boards_mutation_response
  """
  update single row of the table: "boards"
  """
  update_boards_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: boards_set_input,pk_columns: boards_pk_columns_input!  ): boards
  """
  update multiples rows of table: "boards"
  """
  update_boards_many(
    "updates to execute, in order"
    updates: [boards_updates!]!
  ): [boards_mutation_response]
  """
  update data of the table: "cardBadges"
  """
  update_cardBadges(
    "increments the numeric columns with given value of the filtered values"
    _inc: cardBadges_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: cardBadges_set_input,
    "filter the rows which have to be updated"
    where: cardBadges_bool_exp!
  ): cardBadges_mutation_response
  """
  update single row of the table: "cardBadges"
  """
  update_cardBadges_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: cardBadges_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: cardBadges_set_input,pk_columns: cardBadges_pk_columns_input!  ): cardBadges
  """
  update multiples rows of table: "cardBadges"
  """
  update_cardBadges_many(
    "updates to execute, in order"
    updates: [cardBadges_updates!]!
  ): [cardBadges_mutation_response]
  """
  update data of the table: "cardCovers"
  """
  update_cardCovers(
    "sets the columns of the filtered rows to the given values"
    _set: cardCovers_set_input,
    "filter the rows which have to be updated"
    where: cardCovers_bool_exp!
  ): cardCovers_mutation_response
  """
  update single row of the table: "cardCovers"
  """
  update_cardCovers_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: cardCovers_set_input,pk_columns: cardCovers_pk_columns_input!  ): cardCovers
  """
  update multiples rows of table: "cardCovers"
  """
  update_cardCovers_many(
    "updates to execute, in order"
    updates: [cardCovers_updates!]!
  ): [cardCovers_mutation_response]
  """
  update data of the table: "cardLabels"
  """
  update_cardLabels(
    "sets the columns of the filtered rows to the given values"
    _set: cardLabels_set_input,
    "filter the rows which have to be updated"
    where: cardLabels_bool_exp!
  ): cardLabels_mutation_response
  """
  update single row of the table: "cardLabels"
  """
  update_cardLabels_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: cardLabels_set_input,pk_columns: cardLabels_pk_columns_input!  ): cardLabels
  """
  update multiples rows of table: "cardLabels"
  """
  update_cardLabels_many(
    "updates to execute, in order"
    updates: [cardLabels_updates!]!
  ): [cardLabels_mutation_response]
  """
  update data of the table: "cardMembers"
  """
  update_cardMembers(
    "sets the columns of the filtered rows to the given values"
    _set: cardMembers_set_input,
    "filter the rows which have to be updated"
    where: cardMembers_bool_exp!
  ): cardMembers_mutation_response
  """
  update data of the table: "cardMembersVoted"
  """
  update_cardMembersVoted(
    "sets the columns of the filtered rows to the given values"
    _set: cardMembersVoted_set_input,
    "filter the rows which have to be updated"
    where: cardMembersVoted_bool_exp!
  ): cardMembersVoted_mutation_response
  """
  update single row of the table: "cardMembersVoted"
  """
  update_cardMembersVoted_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: cardMembersVoted_set_input,pk_columns: cardMembersVoted_pk_columns_input!  ): cardMembersVoted
  """
  update multiples rows of table: "cardMembersVoted"
  """
  update_cardMembersVoted_many(
    "updates to execute, in order"
    updates: [cardMembersVoted_updates!]!
  ): [cardMembersVoted_mutation_response]
  """
  update single row of the table: "cardMembers"
  """
  update_cardMembers_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: cardMembers_set_input,pk_columns: cardMembers_pk_columns_input!  ): cardMembers
  """
  update multiples rows of table: "cardMembers"
  """
  update_cardMembers_many(
    "updates to execute, in order"
    updates: [cardMembers_updates!]!
  ): [cardMembers_mutation_response]
  """
  update data of the table: "cards"
  """
  update_cards(
    "increments the numeric columns with given value of the filtered values"
    _inc: cards_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: cards_set_input,
    "filter the rows which have to be updated"
    where: cards_bool_exp!
  ): cards_mutation_response
  """
  update single row of the table: "cards"
  """
  update_cards_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: cards_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: cards_set_input,pk_columns: cards_pk_columns_input!  ): cards
  """
  update multiples rows of table: "cards"
  """
  update_cards_many(
    "updates to execute, in order"
    updates: [cards_updates!]!
  ): [cards_mutation_response]
  """
  update data of the table: "checkItems"
  """
  update_checkItems(
    "increments the numeric columns with given value of the filtered values"
    _inc: checkItems_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: checkItems_set_input,
    "filter the rows which have to be updated"
    where: checkItems_bool_exp!
  ): checkItems_mutation_response
  """
  update single row of the table: "checkItems"
  """
  update_checkItems_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: checkItems_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: checkItems_set_input,pk_columns: checkItems_pk_columns_input!  ): checkItems
  """
  update multiples rows of table: "checkItems"
  """
  update_checkItems_many(
    "updates to execute, in order"
    updates: [checkItems_updates!]!
  ): [checkItems_mutation_response]
  """
  update data of the table: "checklists"
  """
  update_checklists(
    "increments the numeric columns with given value of the filtered values"
    _inc: checklists_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: checklists_set_input,
    "filter the rows which have to be updated"
    where: checklists_bool_exp!
  ): checklists_mutation_response
  """
  update single row of the table: "checklists"
  """
  update_checklists_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: checklists_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: checklists_set_input,pk_columns: checklists_pk_columns_input!  ): checklists
  """
  update multiples rows of table: "checklists"
  """
  update_checklists_many(
    "updates to execute, in order"
    updates: [checklists_updates!]!
  ): [checklists_mutation_response]
  """
  update data of the table: "customBoardBackgrounds"
  """
  update_customBoardBackgrounds(
    "sets the columns of the filtered rows to the given values"
    _set: customBoardBackgrounds_set_input,
    "filter the rows which have to be updated"
    where: customBoardBackgrounds_bool_exp!
  ): customBoardBackgrounds_mutation_response
  """
  update single row of the table: "customBoardBackgrounds"
  """
  update_customBoardBackgrounds_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: customBoardBackgrounds_set_input,pk_columns: customBoardBackgrounds_pk_columns_input!  ): customBoardBackgrounds
  """
  update multiples rows of table: "customBoardBackgrounds"
  """
  update_customBoardBackgrounds_many(
    "updates to execute, in order"
    updates: [customBoardBackgrounds_updates!]!
  ): [customBoardBackgrounds_mutation_response]
  """
  update data of the table: "customEmojis"
  """
  update_customEmojis(
    "sets the columns of the filtered rows to the given values"
    _set: customEmojis_set_input,
    "filter the rows which have to be updated"
    where: customEmojis_bool_exp!
  ): customEmojis_mutation_response
  """
  update single row of the table: "customEmojis"
  """
  update_customEmojis_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: customEmojis_set_input,pk_columns: customEmojis_pk_columns_input!  ): customEmojis
  """
  update multiples rows of table: "customEmojis"
  """
  update_customEmojis_many(
    "updates to execute, in order"
    updates: [customEmojis_updates!]!
  ): [customEmojis_mutation_response]
  """
  update data of the table: "customStickers"
  """
  update_customStickers(
    "sets the columns of the filtered rows to the given values"
    _set: customStickers_set_input,
    "filter the rows which have to be updated"
    where: customStickers_bool_exp!
  ): customStickers_mutation_response
  """
  update single row of the table: "customStickers"
  """
  update_customStickers_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: customStickers_set_input,pk_columns: customStickers_pk_columns_input!  ): customStickers
  """
  update multiples rows of table: "customStickers"
  """
  update_customStickers_many(
    "updates to execute, in order"
    updates: [customStickers_updates!]!
  ): [customStickers_mutation_response]
  """
  update data of the table: "labels"
  """
  update_labels(
    "sets the columns of the filtered rows to the given values"
    _set: labels_set_input,
    "filter the rows which have to be updated"
    where: labels_bool_exp!
  ): labels_mutation_response
  """
  update single row of the table: "labels"
  """
  update_labels_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: labels_set_input,pk_columns: labels_pk_columns_input!  ): labels
  """
  update multiples rows of table: "labels"
  """
  update_labels_many(
    "updates to execute, in order"
    updates: [labels_updates!]!
  ): [labels_mutation_response]
  """
  update data of the table: "lists"
  """
  update_lists(
    "increments the numeric columns with given value of the filtered values"
    _inc: lists_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: lists_set_input,
    "filter the rows which have to be updated"
    where: lists_bool_exp!
  ): lists_mutation_response
  """
  update single row of the table: "lists"
  """
  update_lists_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: lists_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: lists_set_input,pk_columns: lists_pk_columns_input!  ): lists
  """
  update multiples rows of table: "lists"
  """
  update_lists_many(
    "updates to execute, in order"
    updates: [lists_updates!]!
  ): [lists_mutation_response]
  """
  update data of the table: "memberPrefs"
  """
  update_memberPrefs(
    "increments the numeric columns with given value of the filtered values"
    _inc: memberPrefs_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: memberPrefs_set_input,
    "filter the rows which have to be updated"
    where: memberPrefs_bool_exp!
  ): memberPrefs_mutation_response
  """
  update single row of the table: "memberPrefs"
  """
  update_memberPrefs_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: memberPrefs_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: memberPrefs_set_input,pk_columns: memberPrefs_pk_columns_input!  ): memberPrefs
  """
  update multiples rows of table: "memberPrefs"
  """
  update_memberPrefs_many(
    "updates to execute, in order"
    updates: [memberPrefs_updates!]!
  ): [memberPrefs_mutation_response]
  """
  update data of the table: "members"
  """
  update_members(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: members_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: members_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: members_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: members_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: members_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: members_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: members_set_input,
    "filter the rows which have to be updated"
    where: members_bool_exp!
  ): members_mutation_response
  """
  update single row of the table: "members"
  """
  update_members_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: members_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: members_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: members_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: members_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: members_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: members_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: members_set_input,pk_columns: members_pk_columns_input!  ): members
  """
  update multiples rows of table: "members"
  """
  update_members_many(
    "updates to execute, in order"
    updates: [members_updates!]!
  ): [members_mutation_response]
  """
  update data of the table: "memberships"
  """
  update_memberships(
    "sets the columns of the filtered rows to the given values"
    _set: memberships_set_input,
    "filter the rows which have to be updated"
    where: memberships_bool_exp!
  ): memberships_mutation_response
  """
  update single row of the table: "memberships"
  """
  update_memberships_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: memberships_set_input,pk_columns: memberships_pk_columns_input!  ): memberships
  """
  update multiples rows of table: "memberships"
  """
  update_memberships_many(
    "updates to execute, in order"
    updates: [memberships_updates!]!
  ): [memberships_mutation_response]
  """
  update data of the table: "notifications"
  """
  update_notifications(
    "sets the columns of the filtered rows to the given values"
    _set: notifications_set_input,
    "filter the rows which have to be updated"
    where: notifications_bool_exp!
  ): notifications_mutation_response
  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: notifications_set_input,pk_columns: notifications_pk_columns_input!  ): notifications
  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    "updates to execute, in order"
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]
  """
  update data of the table: "organizationPrefs"
  """
  update_organizationPrefs(
    "increments the numeric columns with given value of the filtered values"
    _inc: organizationPrefs_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: organizationPrefs_set_input,
    "filter the rows which have to be updated"
    where: organizationPrefs_bool_exp!
  ): organizationPrefs_mutation_response
  """
  update single row of the table: "organizationPrefs"
  """
  update_organizationPrefs_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: organizationPrefs_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: organizationPrefs_set_input,pk_columns: organizationPrefs_pk_columns_input!  ): organizationPrefs
  """
  update multiples rows of table: "organizationPrefs"
  """
  update_organizationPrefs_many(
    "updates to execute, in order"
    updates: [organizationPrefs_updates!]!
  ): [organizationPrefs_mutation_response]
  """
  update data of the table: "organizations"
  """
  update_organizations(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: organizations_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: organizations_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: organizations_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: organizations_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: organizations_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: organizations_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: organizations_set_input,
    "filter the rows which have to be updated"
    where: organizations_bool_exp!
  ): organizations_mutation_response
  """
  update single row of the table: "organizations"
  """
  update_organizations_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: organizations_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: organizations_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: organizations_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: organizations_delete_key_input,
    "increments the numeric columns with given value of the filtered values"
    _inc: organizations_inc_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: organizations_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: organizations_set_input,pk_columns: organizations_pk_columns_input!  ): organizations
  """
  update multiples rows of table: "organizations"
  """
  update_organizations_many(
    "updates to execute, in order"
    updates: [organizations_updates!]!
  ): [organizations_mutation_response]
  """
  update data of the table: "savedSearches"
  """
  update_savedSearches(
    "sets the columns of the filtered rows to the given values"
    _set: savedSearches_set_input,
    "filter the rows which have to be updated"
    where: savedSearches_bool_exp!
  ): savedSearches_mutation_response
  """
  update single row of the table: "savedSearches"
  """
  update_savedSearches_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: savedSearches_set_input,pk_columns: savedSearches_pk_columns_input!  ): savedSearches
  """
  update multiples rows of table: "savedSearches"
  """
  update_savedSearches_many(
    "updates to execute, in order"
    updates: [savedSearches_updates!]!
  ): [savedSearches_mutation_response]
  """
  update data of the table: "sessions"
  """
  update_sessions(
    "sets the columns of the filtered rows to the given values"
    _set: sessions_set_input,
    "filter the rows which have to be updated"
    where: sessions_bool_exp!
  ): sessions_mutation_response
  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: sessions_set_input,pk_columns: sessions_pk_columns_input!  ): sessions
  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    "updates to execute, in order"
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]
  """
  update data of the table: "stickers"
  """
  update_stickers(
    "increments the numeric columns with given value of the filtered values"
    _inc: stickers_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: stickers_set_input,
    "filter the rows which have to be updated"
    where: stickers_bool_exp!
  ): stickers_mutation_response
  """
  update single row of the table: "stickers"
  """
  update_stickers_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: stickers_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: stickers_set_input,pk_columns: stickers_pk_columns_input!  ): stickers
  """
  update multiples rows of table: "stickers"
  """
  update_stickers_many(
    "updates to execute, in order"
    updates: [stickers_updates!]!
  ): [stickers_mutation_response]
  """
  update data of the table: "tokenPermissions"
  """
  update_tokenPermissions(
    "sets the columns of the filtered rows to the given values"
    _set: tokenPermissions_set_input,
    "filter the rows which have to be updated"
    where: tokenPermissions_bool_exp!
  ): tokenPermissions_mutation_response
  """
  update single row of the table: "tokenPermissions"
  """
  update_tokenPermissions_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: tokenPermissions_set_input,pk_columns: tokenPermissions_pk_columns_input!  ): tokenPermissions
  """
  update multiples rows of table: "tokenPermissions"
  """
  update_tokenPermissions_many(
    "updates to execute, in order"
    updates: [tokenPermissions_updates!]!
  ): [tokenPermissions_mutation_response]
  """
  update data of the table: "tokens"
  """
  update_tokens(
    "sets the columns of the filtered rows to the given values"
    _set: tokens_set_input,
    "filter the rows which have to be updated"
    where: tokens_bool_exp!
  ): tokens_mutation_response
  """
  update single row of the table: "tokens"
  """
  update_tokens_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: tokens_set_input,pk_columns: tokens_pk_columns_input!  ): tokens
  """
  update multiples rows of table: "tokens"
  """
  update_tokens_many(
    "updates to execute, in order"
    updates: [tokens_updates!]!
  ): [tokens_mutation_response]
  """
  update data of the table: "users"
  """
  update_users(
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input,
    "filter the rows which have to be updated"
    where: users_bool_exp!
  ): users_mutation_response
  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input,pk_columns: users_pk_columns_input!  ): users
  """
  update multiples rows of table: "users"
  """
  update_users_many(
    "updates to execute, in order"
    updates: [users_updates!]!
  ): [users_mutation_response]
  """
  update data of the table: "verification_tokens"
  """
  update_verification_tokens(
    "sets the columns of the filtered rows to the given values"
    _set: verification_tokens_set_input,
    "filter the rows which have to be updated"
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response
  """
  update single row of the table: "verification_tokens"
  """
  update_verification_tokens_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: verification_tokens_set_input,pk_columns: verification_tokens_pk_columns_input!  ): verification_tokens
  """
  update multiples rows of table: "verification_tokens"
  """
  update_verification_tokens_many(
    "updates to execute, in order"
    updates: [verification_tokens_updates!]!
  ): [verification_tokens_mutation_response]
}
"""
columns and relationships of "notifications"
"""
type notifications {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String!
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
  unread: Boolean
}
"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}
"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
}
"aggregate max on columns"
type notifications_max_fields {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
}
"aggregate min on columns"
type notifications_min_fields {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
}
"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [notifications!]!
}
"""
columns and relationships of "organizationMemberships"
"""
type organizationMemberships {
  deactivated: Boolean
  id: String
  idMember: String
  idOrganization: String
  memberType: String
  unconfirmed: Boolean
}
"""
aggregated selection of "organizationMemberships"
"""
type organizationMemberships_aggregate {
  aggregate: organizationMemberships_aggregate_fields
  nodes: [organizationMemberships!]!
}
"""
aggregate fields of "organizationMemberships"
"""
type organizationMemberships_aggregate_fields {
  count(columns: [organizationMemberships_select_column!], distinct: Boolean): Int!
  max: organizationMemberships_max_fields
  min: organizationMemberships_min_fields
}
"aggregate max on columns"
type organizationMemberships_max_fields {
  id: String
  idMember: String
  idOrganization: String
  memberType: String
}
"aggregate min on columns"
type organizationMemberships_min_fields {
  id: String
  idMember: String
  idOrganization: String
  memberType: String
}
"""
columns and relationships of "organizationPrefs"
"""
type organizationPrefs {
  associatedDomain: String
  boardInviteRestrict: String
  externalMembersDisabled: Boolean
  googleAppsVersion: numeric
  id: String!
  permissionLevel: String
}
"""
aggregated selection of "organizationPrefs"
"""
type organizationPrefs_aggregate {
  aggregate: organizationPrefs_aggregate_fields
  nodes: [organizationPrefs!]!
}
"""
aggregate fields of "organizationPrefs"
"""
type organizationPrefs_aggregate_fields {
  avg: organizationPrefs_avg_fields
  count(columns: [organizationPrefs_select_column!], distinct: Boolean): Int!
  max: organizationPrefs_max_fields
  min: organizationPrefs_min_fields
  stddev: organizationPrefs_stddev_fields
  stddev_pop: organizationPrefs_stddev_pop_fields
  stddev_samp: organizationPrefs_stddev_samp_fields
  sum: organizationPrefs_sum_fields
  var_pop: organizationPrefs_var_pop_fields
  var_samp: organizationPrefs_var_samp_fields
  variance: organizationPrefs_variance_fields
}
"aggregate avg on columns"
type organizationPrefs_avg_fields {
  googleAppsVersion: Float
}
"aggregate max on columns"
type organizationPrefs_max_fields {
  associatedDomain: String
  boardInviteRestrict: String
  googleAppsVersion: numeric
  id: String
  permissionLevel: String
}
"aggregate min on columns"
type organizationPrefs_min_fields {
  associatedDomain: String
  boardInviteRestrict: String
  googleAppsVersion: numeric
  id: String
  permissionLevel: String
}
"""
response of any mutation on the table "organizationPrefs"
"""
type organizationPrefs_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [organizationPrefs!]!
}
"aggregate stddev on columns"
type organizationPrefs_stddev_fields {
  googleAppsVersion: Float
}
"aggregate stddev_pop on columns"
type organizationPrefs_stddev_pop_fields {
  googleAppsVersion: Float
}
"aggregate stddev_samp on columns"
type organizationPrefs_stddev_samp_fields {
  googleAppsVersion: Float
}
"aggregate sum on columns"
type organizationPrefs_sum_fields {
  googleAppsVersion: numeric
}
"aggregate var_pop on columns"
type organizationPrefs_var_pop_fields {
  googleAppsVersion: Float
}
"aggregate var_samp on columns"
type organizationPrefs_var_samp_fields {
  googleAppsVersion: Float
}
"aggregate variance on columns"
type organizationPrefs_variance_fields {
  googleAppsVersion: Float
}
"""
columns and relationships of "organizations"
"""
type organizations {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  """
  fetch data from the table: "boards"
  """
  boards(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): [boards!]!
  """
  fetch aggregated fields from the table: "boards"
  """
  boards_aggregate(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): boards_aggregate!
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String!
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): [organizationMemberships!]!
  "An aggregate relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): organizationMemberships_aggregate!
  name: String
  "An object relationship"
  prefs: organizationPrefs
  premiumFeatures(
    "JSON select path"
    path: String
  ): jsonb
  url: String
  website: String
}
"""
aggregated selection of "organizations"
"""
type organizations_aggregate {
  aggregate: organizations_aggregate_fields
  nodes: [organizations!]!
}
"""
aggregate fields of "organizations"
"""
type organizations_aggregate_fields {
  avg: organizations_avg_fields
  count(columns: [organizations_select_column!], distinct: Boolean): Int!
  max: organizations_max_fields
  min: organizations_min_fields
  stddev: organizations_stddev_fields
  stddev_pop: organizations_stddev_pop_fields
  stddev_samp: organizations_stddev_samp_fields
  sum: organizations_sum_fields
  var_pop: organizations_var_pop_fields
  var_samp: organizations_var_samp_fields
  variance: organizations_variance_fields
}
"aggregate avg on columns"
type organizations_avg_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate max on columns"
type organizations_max_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMemberCreator: String
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  url: String
  website: String
}
"aggregate min on columns"
type organizations_min_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMemberCreator: String
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  url: String
  website: String
}
"""
response of any mutation on the table "organizations"
"""
type organizations_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [organizations!]!
}
"aggregate stddev on columns"
type organizations_stddev_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate stddev_pop on columns"
type organizations_stddev_pop_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate stddev_samp on columns"
type organizations_stddev_samp_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate sum on columns"
type organizations_sum_fields {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  membersCount: numeric
}
"aggregate var_pop on columns"
type organizations_var_pop_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate var_samp on columns"
type organizations_var_samp_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
"aggregate variance on columns"
type organizations_variance_fields {
  billableCollaboratorCount: Float
  billableMemberCount: Float
  membersCount: Float
}
type query_root {
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  """
  fetch data from the table: "accounts" using primary key columns
  """
  accounts_by_pk(id: uuid!): accounts
  "An array relationship"
  attachments(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): [attachments!]!
  "An aggregate relationship"
  attachments_aggregate(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): attachments_aggregate!
  """
  fetch data from the table: "attachments" using primary key columns
  """
  attachments_by_pk(id: String!): attachments
  """
  fetch data from the table: "boardBackgrounds"
  """
  boardBackgrounds(
    "distinct select on columns"
    distinct_on: [boardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardBackgrounds_order_by!],
    "filter the rows returned"
    where: boardBackgrounds_bool_exp
  ): [boardBackgrounds!]!
  """
  fetch aggregated fields from the table: "boardBackgrounds"
  """
  boardBackgrounds_aggregate(
    "distinct select on columns"
    distinct_on: [boardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardBackgrounds_order_by!],
    "filter the rows returned"
    where: boardBackgrounds_bool_exp
  ): boardBackgrounds_aggregate!
  """
  fetch data from the table: "boardBackgrounds" using primary key columns
  """
  boardBackgrounds_by_pk(id: String!): boardBackgrounds
  """
  fetch data from the table: "boardPrefs"
  """
  boardPrefs(
    "distinct select on columns"
    distinct_on: [boardPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardPrefs_order_by!],
    "filter the rows returned"
    where: boardPrefs_bool_exp
  ): [boardPrefs!]!
  """
  fetch aggregated fields from the table: "boardPrefs"
  """
  boardPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [boardPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardPrefs_order_by!],
    "filter the rows returned"
    where: boardPrefs_bool_exp
  ): boardPrefs_aggregate!
  """
  fetch data from the table: "boardPrefs" using primary key columns
  """
  boardPrefs_by_pk(id: String!): boardPrefs
  "An array relationship"
  boardStars(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): [boardStars!]!
  "An aggregate relationship"
  boardStars_aggregate(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): boardStars_aggregate!
  """
  fetch data from the table: "boardStars" using primary key columns
  """
  boardStars_by_pk(id: String!): boardStars
  """
  fetch data from the table: "boards"
  """
  boards(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): [boards!]!
  """
  fetch aggregated fields from the table: "boards"
  """
  boards_aggregate(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): boards_aggregate!
  """
  fetch data from the table: "boards" using primary key columns
  """
  boards_by_pk(id: String!): boards
  """
  fetch data from the table: "cardBadges"
  """
  cardBadges(
    "distinct select on columns"
    distinct_on: [cardBadges_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardBadges_order_by!],
    "filter the rows returned"
    where: cardBadges_bool_exp
  ): [cardBadges!]!
  """
  fetch aggregated fields from the table: "cardBadges"
  """
  cardBadges_aggregate(
    "distinct select on columns"
    distinct_on: [cardBadges_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardBadges_order_by!],
    "filter the rows returned"
    where: cardBadges_bool_exp
  ): cardBadges_aggregate!
  """
  fetch data from the table: "cardBadges" using primary key columns
  """
  cardBadges_by_pk(id: String!): cardBadges
  """
  fetch data from the table: "cardCovers"
  """
  cardCovers(
    "distinct select on columns"
    distinct_on: [cardCovers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardCovers_order_by!],
    "filter the rows returned"
    where: cardCovers_bool_exp
  ): [cardCovers!]!
  """
  fetch aggregated fields from the table: "cardCovers"
  """
  cardCovers_aggregate(
    "distinct select on columns"
    distinct_on: [cardCovers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardCovers_order_by!],
    "filter the rows returned"
    where: cardCovers_bool_exp
  ): cardCovers_aggregate!
  """
  fetch data from the table: "cardCovers" using primary key columns
  """
  cardCovers_by_pk(id: String!): cardCovers
  """
  fetch data from the table: "cardLabels"
  """
  cardLabels(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): [cardLabels!]!
  """
  fetch aggregated fields from the table: "cardLabels"
  """
  cardLabels_aggregate(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): cardLabels_aggregate!
  """
  fetch data from the table: "cardLabels" using primary key columns
  """
  cardLabels_by_pk(id: String!): cardLabels
  """
  fetch data from the table: "cardMembers"
  """
  cardMembers(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): [cardMembers!]!
  """
  fetch data from the table: "cardMembersVoted"
  """
  cardMembersVoted(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): [cardMembersVoted!]!
  """
  fetch aggregated fields from the table: "cardMembersVoted"
  """
  cardMembersVoted_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): cardMembersVoted_aggregate!
  """
  fetch data from the table: "cardMembersVoted" using primary key columns
  """
  cardMembersVoted_by_pk(id: String!): cardMembersVoted
  """
  fetch aggregated fields from the table: "cardMembers"
  """
  cardMembers_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): cardMembers_aggregate!
  """
  fetch data from the table: "cardMembers" using primary key columns
  """
  cardMembers_by_pk(id: String!): cardMembers
  """
  fetch data from the table: "cards"
  """
  cards(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): [cards!]!
  """
  fetch aggregated fields from the table: "cards"
  """
  cards_aggregate(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): cards_aggregate!
  """
  fetch data from the table: "cards" using primary key columns
  """
  cards_by_pk(id: String!): cards
  "An array relationship"
  checkItems(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): [checkItems!]!
  "An aggregate relationship"
  checkItems_aggregate(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): checkItems_aggregate!
  """
  fetch data from the table: "checkItems" using primary key columns
  """
  checkItems_by_pk(id: String!): checkItems
  """
  fetch data from the table: "checklists"
  """
  checklists(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): [checklists!]!
  """
  fetch aggregated fields from the table: "checklists"
  """
  checklists_aggregate(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): checklists_aggregate!
  """
  fetch data from the table: "checklists" using primary key columns
  """
  checklists_by_pk(id: String!): checklists
  "An array relationship"
  customBoardBackgrounds(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): [customBoardBackgrounds!]!
  "An aggregate relationship"
  customBoardBackgrounds_aggregate(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): customBoardBackgrounds_aggregate!
  """
  fetch data from the table: "customBoardBackgrounds" using primary key columns
  """
  customBoardBackgrounds_by_pk(id: String!): customBoardBackgrounds
  "An array relationship"
  customEmojis(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): [customEmojis!]!
  "An aggregate relationship"
  customEmojis_aggregate(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): customEmojis_aggregate!
  """
  fetch data from the table: "customEmojis" using primary key columns
  """
  customEmojis_by_pk(id: String!): customEmojis
  "An array relationship"
  customStickers(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): [customStickers!]!
  "An aggregate relationship"
  customStickers_aggregate(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): customStickers_aggregate!
  """
  fetch data from the table: "customStickers" using primary key columns
  """
  customStickers_by_pk(id: String!): customStickers
  """
  fetch data from the table: "labels"
  """
  labels(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): [labels!]!
  """
  fetch aggregated fields from the table: "labels"
  """
  labels_aggregate(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): labels_aggregate!
  """
  fetch data from the table: "labels" using primary key columns
  """
  labels_by_pk(id: String!): labels
  "An array relationship"
  lists(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): [lists!]!
  "An aggregate relationship"
  lists_aggregate(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): lists_aggregate!
  """
  fetch data from the table: "lists" using primary key columns
  """
  lists_by_pk(id: String!): lists
  """
  fetch data from the table: "memberOrganizations"
  """
  memberOrganizations(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): [memberOrganizations!]!
  """
  fetch aggregated fields from the table: "memberOrganizations"
  """
  memberOrganizations_aggregate(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): memberOrganizations_aggregate!
  """
  fetch data from the table: "memberPrefs"
  """
  memberPrefs(
    "distinct select on columns"
    distinct_on: [memberPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberPrefs_order_by!],
    "filter the rows returned"
    where: memberPrefs_bool_exp
  ): [memberPrefs!]!
  """
  fetch aggregated fields from the table: "memberPrefs"
  """
  memberPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [memberPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberPrefs_order_by!],
    "filter the rows returned"
    where: memberPrefs_bool_exp
  ): memberPrefs_aggregate!
  """
  fetch data from the table: "memberPrefs" using primary key columns
  """
  memberPrefs_by_pk(id: String!): memberPrefs
  """
  fetch data from the table: "members"
  """
  members(
    "distinct select on columns"
    distinct_on: [members_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [members_order_by!],
    "filter the rows returned"
    where: members_bool_exp
  ): [members!]!
  """
  fetch aggregated fields from the table: "members"
  """
  members_aggregate(
    "distinct select on columns"
    distinct_on: [members_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [members_order_by!],
    "filter the rows returned"
    where: members_bool_exp
  ): members_aggregate!
  """
  fetch data from the table: "members" using primary key columns
  """
  members_by_pk(id: String!): members
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): [memberships!]!
  "An aggregate relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): memberships_aggregate!
  """
  fetch data from the table: "memberships" using primary key columns
  """
  memberships_by_pk(id: String!): memberships
  """
  fetch data from the table: "notifications"
  """
  notifications(
    "distinct select on columns"
    distinct_on: [notifications_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [notifications_order_by!],
    "filter the rows returned"
    where: notifications_bool_exp
  ): [notifications!]!
  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    "distinct select on columns"
    distinct_on: [notifications_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [notifications_order_by!],
    "filter the rows returned"
    where: notifications_bool_exp
  ): notifications_aggregate!
  """
  fetch data from the table: "notifications" using primary key columns
  """
  notifications_by_pk(id: String!): notifications
  """
  fetch data from the table: "organizationMemberships"
  """
  organizationMemberships(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): [organizationMemberships!]!
  """
  fetch aggregated fields from the table: "organizationMemberships"
  """
  organizationMemberships_aggregate(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): organizationMemberships_aggregate!
  """
  fetch data from the table: "organizationPrefs"
  """
  organizationPrefs(
    "distinct select on columns"
    distinct_on: [organizationPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationPrefs_order_by!],
    "filter the rows returned"
    where: organizationPrefs_bool_exp
  ): [organizationPrefs!]!
  """
  fetch aggregated fields from the table: "organizationPrefs"
  """
  organizationPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [organizationPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationPrefs_order_by!],
    "filter the rows returned"
    where: organizationPrefs_bool_exp
  ): organizationPrefs_aggregate!
  """
  fetch data from the table: "organizationPrefs" using primary key columns
  """
  organizationPrefs_by_pk(id: String!): organizationPrefs
  """
  fetch data from the table: "organizations"
  """
  organizations(
    "distinct select on columns"
    distinct_on: [organizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizations_order_by!],
    "filter the rows returned"
    where: organizations_bool_exp
  ): [organizations!]!
  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    "distinct select on columns"
    distinct_on: [organizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizations_order_by!],
    "filter the rows returned"
    where: organizations_bool_exp
  ): organizations_aggregate!
  """
  fetch data from the table: "organizations" using primary key columns
  """
  organizations_by_pk(id: String!): organizations
  "An array relationship"
  savedSearches(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): [savedSearches!]!
  "An aggregate relationship"
  savedSearches_aggregate(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): savedSearches_aggregate!
  """
  fetch data from the table: "savedSearches" using primary key columns
  """
  savedSearches_by_pk(id: String!): savedSearches
  "An array relationship"
  sessions(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): [sessions!]!
  "An aggregate relationship"
  sessions_aggregate(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): sessions_aggregate!
  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: uuid!): sessions
  "An array relationship"
  stickers(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): [stickers!]!
  "An aggregate relationship"
  stickers_aggregate(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): stickers_aggregate!
  """
  fetch data from the table: "stickers" using primary key columns
  """
  stickers_by_pk(id: String!): stickers
  """
  fetch data from the table: "tokenPermissions"
  """
  tokenPermissions(
    "distinct select on columns"
    distinct_on: [tokenPermissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokenPermissions_order_by!],
    "filter the rows returned"
    where: tokenPermissions_bool_exp
  ): [tokenPermissions!]!
  """
  fetch aggregated fields from the table: "tokenPermissions"
  """
  tokenPermissions_aggregate(
    "distinct select on columns"
    distinct_on: [tokenPermissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokenPermissions_order_by!],
    "filter the rows returned"
    where: tokenPermissions_bool_exp
  ): tokenPermissions_aggregate!
  """
  fetch data from the table: "tokenPermissions" using primary key columns
  """
  tokenPermissions_by_pk(id: String!): tokenPermissions
  "An array relationship"
  tokens(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): [tokens!]!
  "An aggregate relationship"
  tokens_aggregate(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): tokens_aggregate!
  """
  fetch data from the table: "tokens" using primary key columns
  """
  tokens_by_pk(id: String!): tokens
  """
  fetch data from the table: "users"
  """
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): users_aggregate!
  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users
  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    "distinct select on columns"
    distinct_on: [verification_tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [verification_tokens_order_by!],
    "filter the rows returned"
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!
  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [verification_tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [verification_tokens_order_by!],
    "filter the rows returned"
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!
  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens
}
"""
columns and relationships of "savedSearches"
"""
type savedSearches {
  id: String!
  idMember: String
  name: String
  pos: String
  query: String
}
"""
aggregated selection of "savedSearches"
"""
type savedSearches_aggregate {
  aggregate: savedSearches_aggregate_fields
  nodes: [savedSearches!]!
}
"""
aggregate fields of "savedSearches"
"""
type savedSearches_aggregate_fields {
  count(columns: [savedSearches_select_column!], distinct: Boolean): Int!
  max: savedSearches_max_fields
  min: savedSearches_min_fields
}
"aggregate max on columns"
type savedSearches_max_fields {
  id: String
  idMember: String
  name: String
  pos: String
  query: String
}
"aggregate min on columns"
type savedSearches_min_fields {
  id: String
  idMember: String
  name: String
  pos: String
  query: String
}
"""
response of any mutation on the table "savedSearches"
"""
type savedSearches_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [savedSearches!]!
}
"""
columns and relationships of "sessions"
"""
type sessions {
  expires: timestamptz
  id: uuid!
  sessionToken: String!
  "An object relationship"
  user: users!
  userId: uuid!
}
"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}
"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
}
"aggregate max on columns"
type sessions_max_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}
"aggregate min on columns"
type sessions_min_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}
"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [sessions!]!
}
"""
columns and relationships of "stickers"
"""
type stickers {
  id: String!
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
aggregated selection of "stickers"
"""
type stickers_aggregate {
  aggregate: stickers_aggregate_fields
  nodes: [stickers!]!
}
"""
aggregate fields of "stickers"
"""
type stickers_aggregate_fields {
  avg: stickers_avg_fields
  count(columns: [stickers_select_column!], distinct: Boolean): Int!
  max: stickers_max_fields
  min: stickers_min_fields
  stddev: stickers_stddev_fields
  stddev_pop: stickers_stddev_pop_fields
  stddev_samp: stickers_stddev_samp_fields
  sum: stickers_sum_fields
  var_pop: stickers_var_pop_fields
  var_samp: stickers_var_samp_fields
  variance: stickers_variance_fields
}
"aggregate avg on columns"
type stickers_avg_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate max on columns"
type stickers_max_fields {
  id: String
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"aggregate min on columns"
type stickers_min_fields {
  id: String
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
response of any mutation on the table "stickers"
"""
type stickers_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [stickers!]!
}
"aggregate stddev on columns"
type stickers_stddev_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate stddev_pop on columns"
type stickers_stddev_pop_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate stddev_samp on columns"
type stickers_stddev_samp_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate sum on columns"
type stickers_sum_fields {
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"aggregate var_pop on columns"
type stickers_var_pop_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate var_samp on columns"
type stickers_var_samp_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
"aggregate variance on columns"
type stickers_variance_fields {
  left: Float
  rotate: Float
  top: Float
  zIndex: Float
}
type subscription_root {
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  """
  fetch data from the table: "accounts" using primary key columns
  """
  accounts_by_pk(id: uuid!): accounts
  """
  fetch data from the table in a streaming manner: "accounts"
  """
  accounts_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [accounts_stream_cursor_input]!,
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An array relationship"
  attachments(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): [attachments!]!
  "An aggregate relationship"
  attachments_aggregate(
    "distinct select on columns"
    distinct_on: [attachments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attachments_order_by!],
    "filter the rows returned"
    where: attachments_bool_exp
  ): attachments_aggregate!
  """
  fetch data from the table: "attachments" using primary key columns
  """
  attachments_by_pk(id: String!): attachments
  """
  fetch data from the table in a streaming manner: "attachments"
  """
  attachments_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attachments_stream_cursor_input]!,
    "filter the rows returned"
    where: attachments_bool_exp
  ): [attachments!]!
  """
  fetch data from the table: "boardBackgrounds"
  """
  boardBackgrounds(
    "distinct select on columns"
    distinct_on: [boardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardBackgrounds_order_by!],
    "filter the rows returned"
    where: boardBackgrounds_bool_exp
  ): [boardBackgrounds!]!
  """
  fetch aggregated fields from the table: "boardBackgrounds"
  """
  boardBackgrounds_aggregate(
    "distinct select on columns"
    distinct_on: [boardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardBackgrounds_order_by!],
    "filter the rows returned"
    where: boardBackgrounds_bool_exp
  ): boardBackgrounds_aggregate!
  """
  fetch data from the table: "boardBackgrounds" using primary key columns
  """
  boardBackgrounds_by_pk(id: String!): boardBackgrounds
  """
  fetch data from the table in a streaming manner: "boardBackgrounds"
  """
  boardBackgrounds_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [boardBackgrounds_stream_cursor_input]!,
    "filter the rows returned"
    where: boardBackgrounds_bool_exp
  ): [boardBackgrounds!]!
  """
  fetch data from the table: "boardPrefs"
  """
  boardPrefs(
    "distinct select on columns"
    distinct_on: [boardPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardPrefs_order_by!],
    "filter the rows returned"
    where: boardPrefs_bool_exp
  ): [boardPrefs!]!
  """
  fetch aggregated fields from the table: "boardPrefs"
  """
  boardPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [boardPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardPrefs_order_by!],
    "filter the rows returned"
    where: boardPrefs_bool_exp
  ): boardPrefs_aggregate!
  """
  fetch data from the table: "boardPrefs" using primary key columns
  """
  boardPrefs_by_pk(id: String!): boardPrefs
  """
  fetch data from the table in a streaming manner: "boardPrefs"
  """
  boardPrefs_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [boardPrefs_stream_cursor_input]!,
    "filter the rows returned"
    where: boardPrefs_bool_exp
  ): [boardPrefs!]!
  "An array relationship"
  boardStars(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): [boardStars!]!
  "An aggregate relationship"
  boardStars_aggregate(
    "distinct select on columns"
    distinct_on: [boardStars_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boardStars_order_by!],
    "filter the rows returned"
    where: boardStars_bool_exp
  ): boardStars_aggregate!
  """
  fetch data from the table: "boardStars" using primary key columns
  """
  boardStars_by_pk(id: String!): boardStars
  """
  fetch data from the table in a streaming manner: "boardStars"
  """
  boardStars_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [boardStars_stream_cursor_input]!,
    "filter the rows returned"
    where: boardStars_bool_exp
  ): [boardStars!]!
  """
  fetch data from the table: "boards"
  """
  boards(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): [boards!]!
  """
  fetch aggregated fields from the table: "boards"
  """
  boards_aggregate(
    "distinct select on columns"
    distinct_on: [boards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [boards_order_by!],
    "filter the rows returned"
    where: boards_bool_exp
  ): boards_aggregate!
  """
  fetch data from the table: "boards" using primary key columns
  """
  boards_by_pk(id: String!): boards
  """
  fetch data from the table in a streaming manner: "boards"
  """
  boards_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [boards_stream_cursor_input]!,
    "filter the rows returned"
    where: boards_bool_exp
  ): [boards!]!
  """
  fetch data from the table: "cardBadges"
  """
  cardBadges(
    "distinct select on columns"
    distinct_on: [cardBadges_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardBadges_order_by!],
    "filter the rows returned"
    where: cardBadges_bool_exp
  ): [cardBadges!]!
  """
  fetch aggregated fields from the table: "cardBadges"
  """
  cardBadges_aggregate(
    "distinct select on columns"
    distinct_on: [cardBadges_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardBadges_order_by!],
    "filter the rows returned"
    where: cardBadges_bool_exp
  ): cardBadges_aggregate!
  """
  fetch data from the table: "cardBadges" using primary key columns
  """
  cardBadges_by_pk(id: String!): cardBadges
  """
  fetch data from the table in a streaming manner: "cardBadges"
  """
  cardBadges_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cardBadges_stream_cursor_input]!,
    "filter the rows returned"
    where: cardBadges_bool_exp
  ): [cardBadges!]!
  """
  fetch data from the table: "cardCovers"
  """
  cardCovers(
    "distinct select on columns"
    distinct_on: [cardCovers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardCovers_order_by!],
    "filter the rows returned"
    where: cardCovers_bool_exp
  ): [cardCovers!]!
  """
  fetch aggregated fields from the table: "cardCovers"
  """
  cardCovers_aggregate(
    "distinct select on columns"
    distinct_on: [cardCovers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardCovers_order_by!],
    "filter the rows returned"
    where: cardCovers_bool_exp
  ): cardCovers_aggregate!
  """
  fetch data from the table: "cardCovers" using primary key columns
  """
  cardCovers_by_pk(id: String!): cardCovers
  """
  fetch data from the table in a streaming manner: "cardCovers"
  """
  cardCovers_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cardCovers_stream_cursor_input]!,
    "filter the rows returned"
    where: cardCovers_bool_exp
  ): [cardCovers!]!
  """
  fetch data from the table: "cardLabels"
  """
  cardLabels(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): [cardLabels!]!
  """
  fetch aggregated fields from the table: "cardLabels"
  """
  cardLabels_aggregate(
    "distinct select on columns"
    distinct_on: [cardLabels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardLabels_order_by!],
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): cardLabels_aggregate!
  """
  fetch data from the table: "cardLabels" using primary key columns
  """
  cardLabels_by_pk(id: String!): cardLabels
  """
  fetch data from the table in a streaming manner: "cardLabels"
  """
  cardLabels_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cardLabels_stream_cursor_input]!,
    "filter the rows returned"
    where: cardLabels_bool_exp
  ): [cardLabels!]!
  """
  fetch data from the table: "cardMembers"
  """
  cardMembers(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): [cardMembers!]!
  """
  fetch data from the table: "cardMembersVoted"
  """
  cardMembersVoted(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): [cardMembersVoted!]!
  """
  fetch aggregated fields from the table: "cardMembersVoted"
  """
  cardMembersVoted_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembersVoted_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembersVoted_order_by!],
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): cardMembersVoted_aggregate!
  """
  fetch data from the table: "cardMembersVoted" using primary key columns
  """
  cardMembersVoted_by_pk(id: String!): cardMembersVoted
  """
  fetch data from the table in a streaming manner: "cardMembersVoted"
  """
  cardMembersVoted_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cardMembersVoted_stream_cursor_input]!,
    "filter the rows returned"
    where: cardMembersVoted_bool_exp
  ): [cardMembersVoted!]!
  """
  fetch aggregated fields from the table: "cardMembers"
  """
  cardMembers_aggregate(
    "distinct select on columns"
    distinct_on: [cardMembers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cardMembers_order_by!],
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): cardMembers_aggregate!
  """
  fetch data from the table: "cardMembers" using primary key columns
  """
  cardMembers_by_pk(id: String!): cardMembers
  """
  fetch data from the table in a streaming manner: "cardMembers"
  """
  cardMembers_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cardMembers_stream_cursor_input]!,
    "filter the rows returned"
    where: cardMembers_bool_exp
  ): [cardMembers!]!
  """
  fetch data from the table: "cards"
  """
  cards(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): [cards!]!
  """
  fetch aggregated fields from the table: "cards"
  """
  cards_aggregate(
    "distinct select on columns"
    distinct_on: [cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [cards_order_by!],
    "filter the rows returned"
    where: cards_bool_exp
  ): cards_aggregate!
  """
  fetch data from the table: "cards" using primary key columns
  """
  cards_by_pk(id: String!): cards
  """
  fetch data from the table in a streaming manner: "cards"
  """
  cards_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [cards_stream_cursor_input]!,
    "filter the rows returned"
    where: cards_bool_exp
  ): [cards!]!
  "An array relationship"
  checkItems(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): [checkItems!]!
  "An aggregate relationship"
  checkItems_aggregate(
    "distinct select on columns"
    distinct_on: [checkItems_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checkItems_order_by!],
    "filter the rows returned"
    where: checkItems_bool_exp
  ): checkItems_aggregate!
  """
  fetch data from the table: "checkItems" using primary key columns
  """
  checkItems_by_pk(id: String!): checkItems
  """
  fetch data from the table in a streaming manner: "checkItems"
  """
  checkItems_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [checkItems_stream_cursor_input]!,
    "filter the rows returned"
    where: checkItems_bool_exp
  ): [checkItems!]!
  """
  fetch data from the table: "checklists"
  """
  checklists(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): [checklists!]!
  """
  fetch aggregated fields from the table: "checklists"
  """
  checklists_aggregate(
    "distinct select on columns"
    distinct_on: [checklists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [checklists_order_by!],
    "filter the rows returned"
    where: checklists_bool_exp
  ): checklists_aggregate!
  """
  fetch data from the table: "checklists" using primary key columns
  """
  checklists_by_pk(id: String!): checklists
  """
  fetch data from the table in a streaming manner: "checklists"
  """
  checklists_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [checklists_stream_cursor_input]!,
    "filter the rows returned"
    where: checklists_bool_exp
  ): [checklists!]!
  "An array relationship"
  customBoardBackgrounds(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): [customBoardBackgrounds!]!
  "An aggregate relationship"
  customBoardBackgrounds_aggregate(
    "distinct select on columns"
    distinct_on: [customBoardBackgrounds_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customBoardBackgrounds_order_by!],
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): customBoardBackgrounds_aggregate!
  """
  fetch data from the table: "customBoardBackgrounds" using primary key columns
  """
  customBoardBackgrounds_by_pk(id: String!): customBoardBackgrounds
  """
  fetch data from the table in a streaming manner: "customBoardBackgrounds"
  """
  customBoardBackgrounds_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [customBoardBackgrounds_stream_cursor_input]!,
    "filter the rows returned"
    where: customBoardBackgrounds_bool_exp
  ): [customBoardBackgrounds!]!
  "An array relationship"
  customEmojis(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): [customEmojis!]!
  "An aggregate relationship"
  customEmojis_aggregate(
    "distinct select on columns"
    distinct_on: [customEmojis_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customEmojis_order_by!],
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): customEmojis_aggregate!
  """
  fetch data from the table: "customEmojis" using primary key columns
  """
  customEmojis_by_pk(id: String!): customEmojis
  """
  fetch data from the table in a streaming manner: "customEmojis"
  """
  customEmojis_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [customEmojis_stream_cursor_input]!,
    "filter the rows returned"
    where: customEmojis_bool_exp
  ): [customEmojis!]!
  "An array relationship"
  customStickers(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): [customStickers!]!
  "An aggregate relationship"
  customStickers_aggregate(
    "distinct select on columns"
    distinct_on: [customStickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [customStickers_order_by!],
    "filter the rows returned"
    where: customStickers_bool_exp
  ): customStickers_aggregate!
  """
  fetch data from the table: "customStickers" using primary key columns
  """
  customStickers_by_pk(id: String!): customStickers
  """
  fetch data from the table in a streaming manner: "customStickers"
  """
  customStickers_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [customStickers_stream_cursor_input]!,
    "filter the rows returned"
    where: customStickers_bool_exp
  ): [customStickers!]!
  """
  fetch data from the table: "labels"
  """
  labels(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): [labels!]!
  """
  fetch aggregated fields from the table: "labels"
  """
  labels_aggregate(
    "distinct select on columns"
    distinct_on: [labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [labels_order_by!],
    "filter the rows returned"
    where: labels_bool_exp
  ): labels_aggregate!
  """
  fetch data from the table: "labels" using primary key columns
  """
  labels_by_pk(id: String!): labels
  """
  fetch data from the table in a streaming manner: "labels"
  """
  labels_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [labels_stream_cursor_input]!,
    "filter the rows returned"
    where: labels_bool_exp
  ): [labels!]!
  "An array relationship"
  lists(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): [lists!]!
  "An aggregate relationship"
  lists_aggregate(
    "distinct select on columns"
    distinct_on: [lists_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [lists_order_by!],
    "filter the rows returned"
    where: lists_bool_exp
  ): lists_aggregate!
  """
  fetch data from the table: "lists" using primary key columns
  """
  lists_by_pk(id: String!): lists
  """
  fetch data from the table in a streaming manner: "lists"
  """
  lists_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [lists_stream_cursor_input]!,
    "filter the rows returned"
    where: lists_bool_exp
  ): [lists!]!
  """
  fetch data from the table: "memberOrganizations"
  """
  memberOrganizations(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): [memberOrganizations!]!
  """
  fetch aggregated fields from the table: "memberOrganizations"
  """
  memberOrganizations_aggregate(
    "distinct select on columns"
    distinct_on: [memberOrganizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberOrganizations_order_by!],
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): memberOrganizations_aggregate!
  """
  fetch data from the table in a streaming manner: "memberOrganizations"
  """
  memberOrganizations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [memberOrganizations_stream_cursor_input]!,
    "filter the rows returned"
    where: memberOrganizations_bool_exp
  ): [memberOrganizations!]!
  """
  fetch data from the table: "memberPrefs"
  """
  memberPrefs(
    "distinct select on columns"
    distinct_on: [memberPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberPrefs_order_by!],
    "filter the rows returned"
    where: memberPrefs_bool_exp
  ): [memberPrefs!]!
  """
  fetch aggregated fields from the table: "memberPrefs"
  """
  memberPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [memberPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberPrefs_order_by!],
    "filter the rows returned"
    where: memberPrefs_bool_exp
  ): memberPrefs_aggregate!
  """
  fetch data from the table: "memberPrefs" using primary key columns
  """
  memberPrefs_by_pk(id: String!): memberPrefs
  """
  fetch data from the table in a streaming manner: "memberPrefs"
  """
  memberPrefs_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [memberPrefs_stream_cursor_input]!,
    "filter the rows returned"
    where: memberPrefs_bool_exp
  ): [memberPrefs!]!
  """
  fetch data from the table: "members"
  """
  members(
    "distinct select on columns"
    distinct_on: [members_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [members_order_by!],
    "filter the rows returned"
    where: members_bool_exp
  ): [members!]!
  """
  fetch aggregated fields from the table: "members"
  """
  members_aggregate(
    "distinct select on columns"
    distinct_on: [members_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [members_order_by!],
    "filter the rows returned"
    where: members_bool_exp
  ): members_aggregate!
  """
  fetch data from the table: "members" using primary key columns
  """
  members_by_pk(id: String!): members
  """
  fetch data from the table in a streaming manner: "members"
  """
  members_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [members_stream_cursor_input]!,
    "filter the rows returned"
    where: members_bool_exp
  ): [members!]!
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): [memberships!]!
  "An aggregate relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [memberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [memberships_order_by!],
    "filter the rows returned"
    where: memberships_bool_exp
  ): memberships_aggregate!
  """
  fetch data from the table: "memberships" using primary key columns
  """
  memberships_by_pk(id: String!): memberships
  """
  fetch data from the table in a streaming manner: "memberships"
  """
  memberships_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [memberships_stream_cursor_input]!,
    "filter the rows returned"
    where: memberships_bool_exp
  ): [memberships!]!
  """
  fetch data from the table: "notifications"
  """
  notifications(
    "distinct select on columns"
    distinct_on: [notifications_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [notifications_order_by!],
    "filter the rows returned"
    where: notifications_bool_exp
  ): [notifications!]!
  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    "distinct select on columns"
    distinct_on: [notifications_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [notifications_order_by!],
    "filter the rows returned"
    where: notifications_bool_exp
  ): notifications_aggregate!
  """
  fetch data from the table: "notifications" using primary key columns
  """
  notifications_by_pk(id: String!): notifications
  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [notifications_stream_cursor_input]!,
    "filter the rows returned"
    where: notifications_bool_exp
  ): [notifications!]!
  """
  fetch data from the table: "organizationMemberships"
  """
  organizationMemberships(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): [organizationMemberships!]!
  """
  fetch aggregated fields from the table: "organizationMemberships"
  """
  organizationMemberships_aggregate(
    "distinct select on columns"
    distinct_on: [organizationMemberships_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationMemberships_order_by!],
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): organizationMemberships_aggregate!
  """
  fetch data from the table in a streaming manner: "organizationMemberships"
  """
  organizationMemberships_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [organizationMemberships_stream_cursor_input]!,
    "filter the rows returned"
    where: organizationMemberships_bool_exp
  ): [organizationMemberships!]!
  """
  fetch data from the table: "organizationPrefs"
  """
  organizationPrefs(
    "distinct select on columns"
    distinct_on: [organizationPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationPrefs_order_by!],
    "filter the rows returned"
    where: organizationPrefs_bool_exp
  ): [organizationPrefs!]!
  """
  fetch aggregated fields from the table: "organizationPrefs"
  """
  organizationPrefs_aggregate(
    "distinct select on columns"
    distinct_on: [organizationPrefs_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizationPrefs_order_by!],
    "filter the rows returned"
    where: organizationPrefs_bool_exp
  ): organizationPrefs_aggregate!
  """
  fetch data from the table: "organizationPrefs" using primary key columns
  """
  organizationPrefs_by_pk(id: String!): organizationPrefs
  """
  fetch data from the table in a streaming manner: "organizationPrefs"
  """
  organizationPrefs_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [organizationPrefs_stream_cursor_input]!,
    "filter the rows returned"
    where: organizationPrefs_bool_exp
  ): [organizationPrefs!]!
  """
  fetch data from the table: "organizations"
  """
  organizations(
    "distinct select on columns"
    distinct_on: [organizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizations_order_by!],
    "filter the rows returned"
    where: organizations_bool_exp
  ): [organizations!]!
  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    "distinct select on columns"
    distinct_on: [organizations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [organizations_order_by!],
    "filter the rows returned"
    where: organizations_bool_exp
  ): organizations_aggregate!
  """
  fetch data from the table: "organizations" using primary key columns
  """
  organizations_by_pk(id: String!): organizations
  """
  fetch data from the table in a streaming manner: "organizations"
  """
  organizations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [organizations_stream_cursor_input]!,
    "filter the rows returned"
    where: organizations_bool_exp
  ): [organizations!]!
  "An array relationship"
  savedSearches(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): [savedSearches!]!
  "An aggregate relationship"
  savedSearches_aggregate(
    "distinct select on columns"
    distinct_on: [savedSearches_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [savedSearches_order_by!],
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): savedSearches_aggregate!
  """
  fetch data from the table: "savedSearches" using primary key columns
  """
  savedSearches_by_pk(id: String!): savedSearches
  """
  fetch data from the table in a streaming manner: "savedSearches"
  """
  savedSearches_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [savedSearches_stream_cursor_input]!,
    "filter the rows returned"
    where: savedSearches_bool_exp
  ): [savedSearches!]!
  "An array relationship"
  sessions(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): [sessions!]!
  "An aggregate relationship"
  sessions_aggregate(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): sessions_aggregate!
  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: uuid!): sessions
  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [sessions_stream_cursor_input]!,
    "filter the rows returned"
    where: sessions_bool_exp
  ): [sessions!]!
  "An array relationship"
  stickers(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): [stickers!]!
  "An aggregate relationship"
  stickers_aggregate(
    "distinct select on columns"
    distinct_on: [stickers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [stickers_order_by!],
    "filter the rows returned"
    where: stickers_bool_exp
  ): stickers_aggregate!
  """
  fetch data from the table: "stickers" using primary key columns
  """
  stickers_by_pk(id: String!): stickers
  """
  fetch data from the table in a streaming manner: "stickers"
  """
  stickers_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [stickers_stream_cursor_input]!,
    "filter the rows returned"
    where: stickers_bool_exp
  ): [stickers!]!
  """
  fetch data from the table: "tokenPermissions"
  """
  tokenPermissions(
    "distinct select on columns"
    distinct_on: [tokenPermissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokenPermissions_order_by!],
    "filter the rows returned"
    where: tokenPermissions_bool_exp
  ): [tokenPermissions!]!
  """
  fetch aggregated fields from the table: "tokenPermissions"
  """
  tokenPermissions_aggregate(
    "distinct select on columns"
    distinct_on: [tokenPermissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokenPermissions_order_by!],
    "filter the rows returned"
    where: tokenPermissions_bool_exp
  ): tokenPermissions_aggregate!
  """
  fetch data from the table: "tokenPermissions" using primary key columns
  """
  tokenPermissions_by_pk(id: String!): tokenPermissions
  """
  fetch data from the table in a streaming manner: "tokenPermissions"
  """
  tokenPermissions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [tokenPermissions_stream_cursor_input]!,
    "filter the rows returned"
    where: tokenPermissions_bool_exp
  ): [tokenPermissions!]!
  "An array relationship"
  tokens(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): [tokens!]!
  "An aggregate relationship"
  tokens_aggregate(
    "distinct select on columns"
    distinct_on: [tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [tokens_order_by!],
    "filter the rows returned"
    where: tokens_bool_exp
  ): tokens_aggregate!
  """
  fetch data from the table: "tokens" using primary key columns
  """
  tokens_by_pk(id: String!): tokens
  """
  fetch data from the table in a streaming manner: "tokens"
  """
  tokens_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [tokens_stream_cursor_input]!,
    "filter the rows returned"
    where: tokens_bool_exp
  ): [tokens!]!
  """
  fetch data from the table: "users"
  """
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): users_aggregate!
  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users
  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [users_stream_cursor_input]!,
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    "distinct select on columns"
    distinct_on: [verification_tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [verification_tokens_order_by!],
    "filter the rows returned"
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!
  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [verification_tokens_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [verification_tokens_order_by!],
    "filter the rows returned"
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!
  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens
  """
  fetch data from the table in a streaming manner: "verification_tokens"
  """
  verification_tokens_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [verification_tokens_stream_cursor_input]!,
    "filter the rows returned"
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!
}
"""
columns and relationships of "tokenPermissions"
"""
type tokenPermissions {
  id: String!
  idModel: String
  modelType: String
  read: Boolean
  write: Boolean
}
"""
aggregated selection of "tokenPermissions"
"""
type tokenPermissions_aggregate {
  aggregate: tokenPermissions_aggregate_fields
  nodes: [tokenPermissions!]!
}
"""
aggregate fields of "tokenPermissions"
"""
type tokenPermissions_aggregate_fields {
  count(columns: [tokenPermissions_select_column!], distinct: Boolean): Int!
  max: tokenPermissions_max_fields
  min: tokenPermissions_min_fields
}
"aggregate max on columns"
type tokenPermissions_max_fields {
  id: String
  idModel: String
  modelType: String
}
"aggregate min on columns"
type tokenPermissions_min_fields {
  id: String
  idModel: String
  modelType: String
}
"""
response of any mutation on the table "tokenPermissions"
"""
type tokenPermissions_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [tokenPermissions!]!
}
"""
columns and relationships of "tokens"
"""
type tokens {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String!
  idMember: String
  identifier: String
  "An object relationship"
  permissions: tokenPermissions
}
"""
aggregated selection of "tokens"
"""
type tokens_aggregate {
  aggregate: tokens_aggregate_fields
  nodes: [tokens!]!
}
"""
aggregate fields of "tokens"
"""
type tokens_aggregate_fields {
  count(columns: [tokens_select_column!], distinct: Boolean): Int!
  max: tokens_max_fields
  min: tokens_min_fields
}
"aggregate max on columns"
type tokens_max_fields {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String
  idMember: String
  identifier: String
}
"aggregate min on columns"
type tokens_min_fields {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String
  idMember: String
  identifier: String
}
"""
response of any mutation on the table "tokens"
"""
type tokens_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [tokens!]!
}
"""
columns and relationships of "users"
"""
type users {
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!],
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  email: String
  emailVerified: timestamptz
  id: uuid!
  image: String
  name: String
  "An array relationship"
  sessions(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): [sessions!]!
  "An aggregate relationship"
  sessions_aggregate(
    "distinct select on columns"
    distinct_on: [sessions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sessions_order_by!],
    "filter the rows returned"
    where: sessions_bool_exp
  ): sessions_aggregate!
}
"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}
"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}
"aggregate max on columns"
type users_max_fields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}
"aggregate min on columns"
type users_min_fields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}
"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [users!]!
}
"""
columns and relationships of "verification_tokens"
"""
type verification_tokens {
  expires: timestamptz
  identifier: String!
  token: String!
}
"""
aggregated selection of "verification_tokens"
"""
type verification_tokens_aggregate {
  aggregate: verification_tokens_aggregate_fields
  nodes: [verification_tokens!]!
}
"""
aggregate fields of "verification_tokens"
"""
type verification_tokens_aggregate_fields {
  count(columns: [verification_tokens_select_column!], distinct: Boolean): Int!
  max: verification_tokens_max_fields
  min: verification_tokens_min_fields
}
"aggregate max on columns"
type verification_tokens_max_fields {
  expires: timestamptz
  identifier: String
  token: String
}
"aggregate min on columns"
type verification_tokens_min_fields {
  expires: timestamptz
  identifier: String
  token: String
}
"""
response of any mutation on the table "verification_tokens"
"""
type verification_tokens_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [verification_tokens!]!
}
"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}
"""
select columns of table "accounts"
"""
enum accounts_select_column {
  "column name"
  access_token
  "column name"
  expires_at
  "column name"
  id
  "column name"
  id_token
  "column name"
  oauth_token
  "column name"
  oauth_token_secret
  "column name"
  provider
  "column name"
  providerAccountId
  "column name"
  refresh_token
  "column name"
  refresh_token_expires_in
  "column name"
  scope
  "column name"
  session_state
  "column name"
  token_type
  "column name"
  type
  "column name"
  userId
}
"""
update columns of table "accounts"
"""
enum accounts_update_column {
  "column name"
  access_token
  "column name"
  expires_at
  "column name"
  id
  "column name"
  id_token
  "column name"
  oauth_token
  "column name"
  oauth_token_secret
  "column name"
  provider
  "column name"
  providerAccountId
  "column name"
  refresh_token
  "column name"
  refresh_token_expires_in
  "column name"
  scope
  "column name"
  session_state
  "column name"
  token_type
  "column name"
  type
  "column name"
  userId
}
"""
unique or primary key constraints on table "attachments"
"""
enum attachments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attachments_pkey
}
"""
select columns of table "attachments"
"""
enum attachments_select_column {
  "column name"
  bytes
  "column name"
  date
  "column name"
  edgeColor
  "column name"
  fileName
  "column name"
  id
  "column name"
  idCard
  "column name"
  idMember
  "column name"
  isUpload
  "column name"
  mimeType
  "column name"
  name
  "column name"
  pos
  "column name"
  url
}
"""
select "attachments_aggregate_bool_exp_bool_and_arguments_columns" columns of table "attachments"
"""
enum attachments_select_column_attachments_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  isUpload
}
"""
select "attachments_aggregate_bool_exp_bool_or_arguments_columns" columns of table "attachments"
"""
enum attachments_select_column_attachments_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  isUpload
}
"""
update columns of table "attachments"
"""
enum attachments_update_column {
  "column name"
  bytes
  "column name"
  date
  "column name"
  edgeColor
  "column name"
  fileName
  "column name"
  id
  "column name"
  idCard
  "column name"
  idMember
  "column name"
  isUpload
  "column name"
  mimeType
  "column name"
  name
  "column name"
  pos
  "column name"
  url
}
"""
unique or primary key constraints on table "boardBackgrounds"
"""
enum boardBackgrounds_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  boardBackgrounds_pkey
}
"""
select columns of table "boardBackgrounds"
"""
enum boardBackgrounds_select_column {
  "column name"
  attribution
  "column name"
  bottomColor
  "column name"
  brightness
  "column name"
  color
  "column name"
  emoji
  "column name"
  fullSizeUrl
  "column name"
  id
  "column name"
  tile
  "column name"
  topColor
  "column name"
  type
}
"""
update columns of table "boardBackgrounds"
"""
enum boardBackgrounds_update_column {
  "column name"
  attribution
  "column name"
  bottomColor
  "column name"
  brightness
  "column name"
  color
  "column name"
  emoji
  "column name"
  fullSizeUrl
  "column name"
  id
  "column name"
  tile
  "column name"
  topColor
  "column name"
  type
}
"""
unique or primary key constraints on table "boardPrefs"
"""
enum boardPrefs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  boardPrefs_pkey
}
"""
select columns of table "boardPrefs"
"""
enum boardPrefs_select_column {
  "column name"
  background
  "column name"
  backgroundBottomColor
  "column name"
  backgroundBrightness
  "column name"
  backgroundColor
  "column name"
  backgroundImage
  "column name"
  backgroundTile
  "column name"
  backgroundTopColor
  "column name"
  calendarFeedEnabled
  "column name"
  canBeOrg
  "column name"
  canBePrivate
  "column name"
  canBePublic
  "column name"
  canInvite
  "column name"
  cardAging
  "column name"
  cardCovers
  "column name"
  comments
  "column name"
  hideVotes
  "column name"
  id
  "column name"
  invitations
  "column name"
  isTemplate
  "column name"
  permissionLevel
  "column name"
  selfJoin
  "column name"
  voting
}
"""
update columns of table "boardPrefs"
"""
enum boardPrefs_update_column {
  "column name"
  background
  "column name"
  backgroundBottomColor
  "column name"
  backgroundBrightness
  "column name"
  backgroundColor
  "column name"
  backgroundImage
  "column name"
  backgroundTile
  "column name"
  backgroundTopColor
  "column name"
  calendarFeedEnabled
  "column name"
  canBeOrg
  "column name"
  canBePrivate
  "column name"
  canBePublic
  "column name"
  canInvite
  "column name"
  cardAging
  "column name"
  cardCovers
  "column name"
  comments
  "column name"
  hideVotes
  "column name"
  id
  "column name"
  invitations
  "column name"
  isTemplate
  "column name"
  permissionLevel
  "column name"
  selfJoin
  "column name"
  voting
}
"""
unique or primary key constraints on table "boardStars"
"""
enum boardStars_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  boardStars_pkey
}
"""
select columns of table "boardStars"
"""
enum boardStars_select_column {
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idMember
  "column name"
  pos
}
"""
update columns of table "boardStars"
"""
enum boardStars_update_column {
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idMember
  "column name"
  pos
}
"""
unique or primary key constraints on table "boards"
"""
enum boards_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  boards_pkey
}
"""
select columns of table "boards"
"""
enum boards_select_column {
  "column name"
  closed
  "column name"
  dateClosed
  "column name"
  desc
  "column name"
  id
  "column name"
  idMemberCreator
  "column name"
  idOrganization
  "column name"
  name
  "column name"
  pinned
  "column name"
  shortUrl
  "column name"
  url
}
"""
select "boards_aggregate_bool_exp_bool_and_arguments_columns" columns of table "boards"
"""
enum boards_select_column_boards_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  closed
  "column name"
  pinned
}
"""
select "boards_aggregate_bool_exp_bool_or_arguments_columns" columns of table "boards"
"""
enum boards_select_column_boards_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  closed
  "column name"
  pinned
}
"""
update columns of table "boards"
"""
enum boards_update_column {
  "column name"
  closed
  "column name"
  dateClosed
  "column name"
  desc
  "column name"
  id
  "column name"
  idMemberCreator
  "column name"
  idOrganization
  "column name"
  name
  "column name"
  pinned
  "column name"
  shortUrl
  "column name"
  url
}
"""
unique or primary key constraints on table "cardBadges"
"""
enum cardBadges_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cardBadges_pkey
}
"""
select columns of table "cardBadges"
"""
enum cardBadges_select_column {
  "column name"
  attachments
  "column name"
  checkItems
  "column name"
  checkItemsChecked
  "column name"
  checkItemsEarliestdue
  "column name"
  comments
  "column name"
  description
  "column name"
  due
  "column name"
  dueComplete
  "column name"
  fogbugz
  "column name"
  id
  "column name"
  location
  "column name"
  start
  "column name"
  subscribed
  "column name"
  viewingMemberVoted
  "column name"
  votes
}
"""
update columns of table "cardBadges"
"""
enum cardBadges_update_column {
  "column name"
  attachments
  "column name"
  checkItems
  "column name"
  checkItemsChecked
  "column name"
  checkItemsEarliestdue
  "column name"
  comments
  "column name"
  description
  "column name"
  due
  "column name"
  dueComplete
  "column name"
  fogbugz
  "column name"
  id
  "column name"
  location
  "column name"
  start
  "column name"
  subscribed
  "column name"
  viewingMemberVoted
  "column name"
  votes
}
"""
unique or primary key constraints on table "cardCovers"
"""
enum cardCovers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cardCovers_pkey
}
"""
select columns of table "cardCovers"
"""
enum cardCovers_select_column {
  "column name"
  brightness
  "column name"
  color
  "column name"
  id
  "column name"
  idAttachment
  "column name"
  size
}
"""
update columns of table "cardCovers"
"""
enum cardCovers_update_column {
  "column name"
  brightness
  "column name"
  color
  "column name"
  id
  "column name"
  idAttachment
  "column name"
  size
}
"""
unique or primary key constraints on table "cardLabels"
"""
enum cardLabels_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cardLabels_pkey
}
"""
select columns of table "cardLabels"
"""
enum cardLabels_select_column {
  "column name"
  id
  "column name"
  idLabel
}
"""
update columns of table "cardLabels"
"""
enum cardLabels_update_column {
  "column name"
  id
  "column name"
  idLabel
}
"""
unique or primary key constraints on table "cardMembersVoted"
"""
enum cardMembersVoted_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cardMembersVoted_pkey
}
"""
select columns of table "cardMembersVoted"
"""
enum cardMembersVoted_select_column {
  "column name"
  id
  "column name"
  idMember
}
"""
update columns of table "cardMembersVoted"
"""
enum cardMembersVoted_update_column {
  "column name"
  id
  "column name"
  idMember
}
"""
unique or primary key constraints on table "cardMembers"
"""
enum cardMembers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cardMembers_pkey
}
"""
select columns of table "cardMembers"
"""
enum cardMembers_select_column {
  "column name"
  id
  "column name"
  idMember
}
"""
update columns of table "cardMembers"
"""
enum cardMembers_update_column {
  "column name"
  id
  "column name"
  idMember
}
"""
unique or primary key constraints on table "cards"
"""
enum cards_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cards_pkey
}
"""
select columns of table "cards"
"""
enum cards_select_column {
  "column name"
  closed
  "column name"
  dateLastActivity
  "column name"
  desc
  "column name"
  due
  "column name"
  dueComplete
  "column name"
  dueReminder
  "column name"
  email
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idList
  "column name"
  idShort
  "column name"
  isTemplate
  "column name"
  manualCoverAttachment
  "column name"
  name
  "column name"
  pos
  "column name"
  shortLink
  "column name"
  shortUrl
  "column name"
  start
  "column name"
  subscribed
  "column name"
  url
}
"""
select "cards_aggregate_bool_exp_bool_and_arguments_columns" columns of table "cards"
"""
enum cards_select_column_cards_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  closed
  "column name"
  dueComplete
  "column name"
  isTemplate
  "column name"
  manualCoverAttachment
  "column name"
  subscribed
}
"""
select "cards_aggregate_bool_exp_bool_or_arguments_columns" columns of table "cards"
"""
enum cards_select_column_cards_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  closed
  "column name"
  dueComplete
  "column name"
  isTemplate
  "column name"
  manualCoverAttachment
  "column name"
  subscribed
}
"""
update columns of table "cards"
"""
enum cards_update_column {
  "column name"
  closed
  "column name"
  dateLastActivity
  "column name"
  desc
  "column name"
  due
  "column name"
  dueComplete
  "column name"
  dueReminder
  "column name"
  email
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idList
  "column name"
  idShort
  "column name"
  isTemplate
  "column name"
  manualCoverAttachment
  "column name"
  name
  "column name"
  pos
  "column name"
  shortLink
  "column name"
  shortUrl
  "column name"
  start
  "column name"
  subscribed
  "column name"
  url
}
"""
unique or primary key constraints on table "checkItems"
"""
enum checkItems_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  checkItems_pkey
}
"""
select columns of table "checkItems"
"""
enum checkItems_select_column {
  "column name"
  due
  "column name"
  dueReminder
  "column name"
  id
  "column name"
  idChecklist
  "column name"
  name
  "column name"
  pos
  "column name"
  state
}
"""
update columns of table "checkItems"
"""
enum checkItems_update_column {
  "column name"
  due
  "column name"
  dueReminder
  "column name"
  id
  "column name"
  idChecklist
  "column name"
  name
  "column name"
  pos
  "column name"
  state
}
"""
unique or primary key constraints on table "checklists"
"""
enum checklists_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  checklists_pkey
}
"""
select columns of table "checklists"
"""
enum checklists_select_column {
  "column name"
  id
  "column name"
  idCard
  "column name"
  name
  "column name"
  pos
}
"""
update columns of table "checklists"
"""
enum checklists_update_column {
  "column name"
  id
  "column name"
  idCard
  "column name"
  name
  "column name"
  pos
}
"ordering argument of a cursor"
enum cursor_ordering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}
"""
unique or primary key constraints on table "customBoardBackgrounds"
"""
enum customBoardBackgrounds_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customBoardBackgrounds_pkey
}
"""
select columns of table "customBoardBackgrounds"
"""
enum customBoardBackgrounds_select_column {
  "column name"
  bottomColor
  "column name"
  brightness
  "column name"
  fullSizeUrl
  "column name"
  id
  "column name"
  idMember
  "column name"
  tile
  "column name"
  topColor
  "column name"
  type
}
"""
select "customBoardBackgrounds_aggregate_bool_exp_bool_and_arguments_columns" columns of table "customBoardBackgrounds"
"""
enum customBoardBackgrounds_select_column_customBoardBackgrounds_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  tile
}
"""
select "customBoardBackgrounds_aggregate_bool_exp_bool_or_arguments_columns" columns of table "customBoardBackgrounds"
"""
enum customBoardBackgrounds_select_column_customBoardBackgrounds_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  tile
}
"""
update columns of table "customBoardBackgrounds"
"""
enum customBoardBackgrounds_update_column {
  "column name"
  bottomColor
  "column name"
  brightness
  "column name"
  fullSizeUrl
  "column name"
  id
  "column name"
  idMember
  "column name"
  tile
  "column name"
  topColor
  "column name"
  type
}
"""
unique or primary key constraints on table "customEmojis"
"""
enum customEmojis_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customEmojis_pkey
}
"""
select columns of table "customEmojis"
"""
enum customEmojis_select_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  name
  "column name"
  url
}
"""
update columns of table "customEmojis"
"""
enum customEmojis_update_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  name
  "column name"
  url
}
"""
unique or primary key constraints on table "customStickers"
"""
enum customStickers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customStickers_pkey
}
"""
select columns of table "customStickers"
"""
enum customStickers_select_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  url
}
"""
update columns of table "customStickers"
"""
enum customStickers_update_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  url
}
"""
unique or primary key constraints on table "labels"
"""
enum labels_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  labels_pkey
}
"""
select columns of table "labels"
"""
enum labels_select_column {
  "column name"
  color
  "column name"
  id
  "column name"
  idBoard
  "column name"
  name
}
"""
update columns of table "labels"
"""
enum labels_update_column {
  "column name"
  color
  "column name"
  id
  "column name"
  idBoard
  "column name"
  name
}
"""
unique or primary key constraints on table "lists"
"""
enum lists_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  lists_pkey
}
"""
select columns of table "lists"
"""
enum lists_select_column {
  "column name"
  closed
  "column name"
  id
  "column name"
  idBoard
  "column name"
  name
  "column name"
  pos
  "column name"
  softLimit
  "column name"
  subscribed
}
"""
select "lists_aggregate_bool_exp_bool_and_arguments_columns" columns of table "lists"
"""
enum lists_select_column_lists_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  closed
  "column name"
  subscribed
}
"""
select "lists_aggregate_bool_exp_bool_or_arguments_columns" columns of table "lists"
"""
enum lists_select_column_lists_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  closed
  "column name"
  subscribed
}
"""
update columns of table "lists"
"""
enum lists_update_column {
  "column name"
  closed
  "column name"
  id
  "column name"
  idBoard
  "column name"
  name
  "column name"
  pos
  "column name"
  softLimit
  "column name"
  subscribed
}
"""
select columns of table "memberOrganizations"
"""
enum memberOrganizations_select_column {
  "column name"
  billableCollaboratorCount
  "column name"
  billableMemberCount
  "column name"
  creationMethod
  "column name"
  dateLastActivity
  "column name"
  desc
  "column name"
  displayName
  "column name"
  id
  "column name"
  idMember
  "column name"
  idMemberCreator
  "column name"
  invited
  "column name"
  ixUpdate
  "column name"
  logoHash
  "column name"
  logoUrl
  "column name"
  membersCount
  "column name"
  name
  "column name"
  premiumFeatures
  "column name"
  url
  "column name"
  website
}
"""
select "memberOrganizations_aggregate_bool_exp_bool_and_arguments_columns" columns of table "memberOrganizations"
"""
enum memberOrganizations_select_column_memberOrganizations_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  invited
}
"""
select "memberOrganizations_aggregate_bool_exp_bool_or_arguments_columns" columns of table "memberOrganizations"
"""
enum memberOrganizations_select_column_memberOrganizations_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  invited
}
"""
unique or primary key constraints on table "memberPrefs"
"""
enum memberPrefs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  memberPrefs_pkey
}
"""
select columns of table "memberPrefs"
"""
enum memberPrefs_select_column {
  "column name"
  colorBlind
  "column name"
  id
  "column name"
  locale
  "column name"
  minutesBeforeDeadlineToNotify
  "column name"
  minutesBetweenSummaries
  "column name"
  sendSummaries
}
"""
update columns of table "memberPrefs"
"""
enum memberPrefs_update_column {
  "column name"
  colorBlind
  "column name"
  id
  "column name"
  locale
  "column name"
  minutesBeforeDeadlineToNotify
  "column name"
  minutesBetweenSummaries
  "column name"
  sendSummaries
}
"""
unique or primary key constraints on table "members"
"""
enum members_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  members_pkey
}
"""
select columns of table "members"
"""
enum members_select_column {
  "column name"
  activityBlocked
  "column name"
  avatarHash
  "column name"
  avatarSource
  "column name"
  avatarUrl
  "column name"
  bio
  "column name"
  confirmed
  "column name"
  credentialsRemovedCount
  "column name"
  email
  "column name"
  fullName
  "column name"
  gravatarHash
  "column name"
  id
  "column name"
  idMemberReferrer
  "column name"
  initials
  "column name"
  ixUpdate
  "column name"
  loginTypes
  "column name"
  memberType
  "column name"
  nonPublicAvailable
  "column name"
  oneTimeMessagesDismissed
  "column name"
  premiumFeatures
  "column name"
  status
  "column name"
  uploadedAvatarHash
  "column name"
  uploadedAvatarUrl
  "column name"
  url
  "column name"
  username
}
"""
update columns of table "members"
"""
enum members_update_column {
  "column name"
  activityBlocked
  "column name"
  avatarHash
  "column name"
  avatarSource
  "column name"
  avatarUrl
  "column name"
  bio
  "column name"
  confirmed
  "column name"
  credentialsRemovedCount
  "column name"
  email
  "column name"
  fullName
  "column name"
  gravatarHash
  "column name"
  id
  "column name"
  idMemberReferrer
  "column name"
  initials
  "column name"
  ixUpdate
  "column name"
  loginTypes
  "column name"
  memberType
  "column name"
  nonPublicAvailable
  "column name"
  oneTimeMessagesDismissed
  "column name"
  premiumFeatures
  "column name"
  status
  "column name"
  uploadedAvatarHash
  "column name"
  uploadedAvatarUrl
  "column name"
  url
  "column name"
  username
}
"""
unique or primary key constraints on table "memberships"
"""
enum memberships_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  memberships_pkey
}
"""
select columns of table "memberships"
"""
enum memberships_select_column {
  "column name"
  deactivated
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idMember
  "column name"
  memberType
  "column name"
  unconfirmed
}
"""
select "memberships_aggregate_bool_exp_bool_and_arguments_columns" columns of table "memberships"
"""
enum memberships_select_column_memberships_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  deactivated
  "column name"
  unconfirmed
}
"""
select "memberships_aggregate_bool_exp_bool_or_arguments_columns" columns of table "memberships"
"""
enum memberships_select_column_memberships_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  deactivated
  "column name"
  unconfirmed
}
"""
update columns of table "memberships"
"""
enum memberships_update_column {
  "column name"
  deactivated
  "column name"
  id
  "column name"
  idBoard
  "column name"
  idMember
  "column name"
  memberType
  "column name"
  unconfirmed
}
"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}
"""
select columns of table "notifications"
"""
enum notifications_select_column {
  "column name"
  data
  "column name"
  date
  "column name"
  dateRead
  "column name"
  id
  "column name"
  idAction
  "column name"
  idCard
  "column name"
  idMemberCreator
  "column name"
  type
  "column name"
  unread
}
"""
update columns of table "notifications"
"""
enum notifications_update_column {
  "column name"
  data
  "column name"
  date
  "column name"
  dateRead
  "column name"
  id
  "column name"
  idAction
  "column name"
  idCard
  "column name"
  idMemberCreator
  "column name"
  type
  "column name"
  unread
}
"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}
"""
select columns of table "organizationMemberships"
"""
enum organizationMemberships_select_column {
  "column name"
  deactivated
  "column name"
  id
  "column name"
  idMember
  "column name"
  idOrganization
  "column name"
  memberType
  "column name"
  unconfirmed
}
"""
select "organizationMemberships_aggregate_bool_exp_bool_and_arguments_columns" columns of table "organizationMemberships"
"""
enum organizationMemberships_select_column_organizationMemberships_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  deactivated
  "column name"
  unconfirmed
}
"""
select "organizationMemberships_aggregate_bool_exp_bool_or_arguments_columns" columns of table "organizationMemberships"
"""
enum organizationMemberships_select_column_organizationMemberships_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  deactivated
  "column name"
  unconfirmed
}
"""
unique or primary key constraints on table "organizationPrefs"
"""
enum organizationPrefs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organizationPrefs_pkey
}
"""
select columns of table "organizationPrefs"
"""
enum organizationPrefs_select_column {
  "column name"
  associatedDomain
  "column name"
  boardInviteRestrict
  "column name"
  externalMembersDisabled
  "column name"
  googleAppsVersion
  "column name"
  id
  "column name"
  permissionLevel
}
"""
update columns of table "organizationPrefs"
"""
enum organizationPrefs_update_column {
  "column name"
  associatedDomain
  "column name"
  boardInviteRestrict
  "column name"
  externalMembersDisabled
  "column name"
  googleAppsVersion
  "column name"
  id
  "column name"
  permissionLevel
}
"""
unique or primary key constraints on table "organizations"
"""
enum organizations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organizations_pkey
}
"""
select columns of table "organizations"
"""
enum organizations_select_column {
  "column name"
  billableCollaboratorCount
  "column name"
  billableMemberCount
  "column name"
  creationMethod
  "column name"
  dateLastActivity
  "column name"
  desc
  "column name"
  displayName
  "column name"
  id
  "column name"
  idMemberCreator
  "column name"
  invited
  "column name"
  ixUpdate
  "column name"
  logoHash
  "column name"
  logoUrl
  "column name"
  membersCount
  "column name"
  name
  "column name"
  premiumFeatures
  "column name"
  url
  "column name"
  website
}
"""
update columns of table "organizations"
"""
enum organizations_update_column {
  "column name"
  billableCollaboratorCount
  "column name"
  billableMemberCount
  "column name"
  creationMethod
  "column name"
  dateLastActivity
  "column name"
  desc
  "column name"
  displayName
  "column name"
  id
  "column name"
  idMemberCreator
  "column name"
  invited
  "column name"
  ixUpdate
  "column name"
  logoHash
  "column name"
  logoUrl
  "column name"
  membersCount
  "column name"
  name
  "column name"
  premiumFeatures
  "column name"
  url
  "column name"
  website
}
"""
unique or primary key constraints on table "savedSearches"
"""
enum savedSearches_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  savedSearches_pkey
}
"""
select columns of table "savedSearches"
"""
enum savedSearches_select_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  name
  "column name"
  pos
  "column name"
  query
}
"""
update columns of table "savedSearches"
"""
enum savedSearches_update_column {
  "column name"
  id
  "column name"
  idMember
  "column name"
  name
  "column name"
  pos
  "column name"
  query
}
"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}
"""
select columns of table "sessions"
"""
enum sessions_select_column {
  "column name"
  expires
  "column name"
  id
  "column name"
  sessionToken
  "column name"
  userId
}
"""
update columns of table "sessions"
"""
enum sessions_update_column {
  "column name"
  expires
  "column name"
  id
  "column name"
  sessionToken
  "column name"
  userId
}
"""
unique or primary key constraints on table "stickers"
"""
enum stickers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  stickers_pkey
}
"""
select columns of table "stickers"
"""
enum stickers_select_column {
  "column name"
  id
  "column name"
  idCard
  "column name"
  image
  "column name"
  imageUrl
  "column name"
  left
  "column name"
  rotate
  "column name"
  top
  "column name"
  zIndex
}
"""
update columns of table "stickers"
"""
enum stickers_update_column {
  "column name"
  id
  "column name"
  idCard
  "column name"
  image
  "column name"
  imageUrl
  "column name"
  left
  "column name"
  rotate
  "column name"
  top
  "column name"
  zIndex
}
"""
unique or primary key constraints on table "tokenPermissions"
"""
enum tokenPermissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokenPermissions_pkey
}
"""
select columns of table "tokenPermissions"
"""
enum tokenPermissions_select_column {
  "column name"
  id
  "column name"
  idModel
  "column name"
  modelType
  "column name"
  read
  "column name"
  write
}
"""
update columns of table "tokenPermissions"
"""
enum tokenPermissions_update_column {
  "column name"
  id
  "column name"
  idModel
  "column name"
  modelType
  "column name"
  read
  "column name"
  write
}
"""
unique or primary key constraints on table "tokens"
"""
enum tokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokens_pkey
}
"""
select columns of table "tokens"
"""
enum tokens_select_column {
  "column name"
  dateCreated
  "column name"
  dateExpires
  "column name"
  id
  "column name"
  idMember
  "column name"
  identifier
}
"""
update columns of table "tokens"
"""
enum tokens_update_column {
  "column name"
  dateCreated
  "column name"
  dateExpires
  "column name"
  id
  "column name"
  idMember
  "column name"
  identifier
}
"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}
"""
select columns of table "users"
"""
enum users_select_column {
  "column name"
  email
  "column name"
  emailVerified
  "column name"
  id
  "column name"
  image
  "column name"
  name
}
"""
update columns of table "users"
"""
enum users_update_column {
  "column name"
  email
  "column name"
  emailVerified
  "column name"
  id
  "column name"
  image
  "column name"
  name
}
"""
unique or primary key constraints on table "verification_tokens"
"""
enum verification_tokens_constraint {
  """
  unique or primary key constraint on columns "token"
  """
  verification_tokens_pkey
}
"""
select columns of table "verification_tokens"
"""
enum verification_tokens_select_column {
  "column name"
  expires
  "column name"
  identifier
  "column name"
  token
}
"""
update columns of table "verification_tokens"
"""
enum verification_tokens_update_column {
  "column name"
  expires
  "column name"
  identifier
  "column name"
  token
}
"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}
"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}
"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}
input accounts_aggregate_bool_exp {
  count: accounts_aggregate_bool_exp_count
}
input accounts_aggregate_bool_exp_count {
  arguments: [accounts_select_column!]
  distinct: Boolean
  filter: accounts_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "accounts"
"""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}
"""
input type for inserting array relation for remote table "accounts"
"""
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!
  "upsert condition"
  on_conflict: accounts_on_conflict
}
"""
order by avg() on columns of table "accounts"
"""
input accounts_avg_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  access_token: String_comparison_exp
  expires_at: bigint_comparison_exp
  id: uuid_comparison_exp
  id_token: String_comparison_exp
  oauth_token: String_comparison_exp
  oauth_token_secret: String_comparison_exp
  provider: String_comparison_exp
  providerAccountId: String_comparison_exp
  refresh_token: String_comparison_exp
  refresh_token_expires_in: Int_comparison_exp
  scope: String_comparison_exp
  session_state: String_comparison_exp
  token_type: String_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}
"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  expires_at: bigint
  refresh_token_expires_in: Int
}
"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  user: users_obj_rel_insert_input
  userId: uuid
}
"""
order by max() on columns of table "accounts"
"""
input accounts_max_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}
"""
order by min() on columns of table "accounts"
"""
input accounts_min_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}
"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}
"""
Ordering options when selecting data from "accounts".
"""
input accounts_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}
"primary key columns input for table: accounts"
input accounts_pk_columns_input {
  id: uuid!
}
"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}
"""
order by stddev() on columns of table "accounts"
"""
input accounts_stddev_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
order by stddev_pop() on columns of table "accounts"
"""
input accounts_stddev_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
order by stddev_samp() on columns of table "accounts"
"""
input accounts_stddev_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: accounts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input accounts_stream_cursor_value_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}
"""
order by sum() on columns of table "accounts"
"""
input accounts_sum_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
input accounts_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: accounts_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: accounts_set_input
  "filter the rows which have to be updated"
  where: accounts_bool_exp!
}
"""
order by var_pop() on columns of table "accounts"
"""
input accounts_var_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
order by var_samp() on columns of table "accounts"
"""
input accounts_var_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
"""
order by variance() on columns of table "accounts"
"""
input accounts_variance_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}
input attachments_aggregate_bool_exp {
  bool_and: attachments_aggregate_bool_exp_bool_and
  bool_or: attachments_aggregate_bool_exp_bool_or
  count: attachments_aggregate_bool_exp_count
}
input attachments_aggregate_bool_exp_bool_and {
  arguments: attachments_select_column_attachments_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: attachments_bool_exp
  predicate: Boolean_comparison_exp!
}
input attachments_aggregate_bool_exp_bool_or {
  arguments: attachments_select_column_attachments_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: attachments_bool_exp
  predicate: Boolean_comparison_exp!
}
input attachments_aggregate_bool_exp_count {
  arguments: [attachments_select_column!]
  distinct: Boolean
  filter: attachments_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "attachments"
"""
input attachments_aggregate_order_by {
  avg: attachments_avg_order_by
  count: order_by
  max: attachments_max_order_by
  min: attachments_min_order_by
  stddev: attachments_stddev_order_by
  stddev_pop: attachments_stddev_pop_order_by
  stddev_samp: attachments_stddev_samp_order_by
  sum: attachments_sum_order_by
  var_pop: attachments_var_pop_order_by
  var_samp: attachments_var_samp_order_by
  variance: attachments_variance_order_by
}
"""
input type for inserting array relation for remote table "attachments"
"""
input attachments_arr_rel_insert_input {
  data: [attachments_insert_input!]!
  "upsert condition"
  on_conflict: attachments_on_conflict
}
"""
order by avg() on columns of table "attachments"
"""
input attachments_avg_order_by {
  bytes: order_by
  pos: order_by
}
"""
Boolean expression to filter rows from the table "attachments". All fields are combined with a logical 'AND'.
"""
input attachments_bool_exp {
  _and: [attachments_bool_exp!]
  _not: attachments_bool_exp
  _or: [attachments_bool_exp!]
  bytes: numeric_comparison_exp
  date: timestamptz_comparison_exp
  edgeColor: String_comparison_exp
  fileName: String_comparison_exp
  id: String_comparison_exp
  idCard: String_comparison_exp
  idMember: String_comparison_exp
  isUpload: Boolean_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  pos: numeric_comparison_exp
  url: String_comparison_exp
}
"""
input type for incrementing numeric columns in table "attachments"
"""
input attachments_inc_input {
  bytes: numeric
  pos: numeric
}
"""
input type for inserting data into table "attachments"
"""
input attachments_insert_input {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String
  idCard: String
  idMember: String
  isUpload: Boolean
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"""
order by max() on columns of table "attachments"
"""
input attachments_max_order_by {
  bytes: order_by
  date: order_by
  edgeColor: order_by
  fileName: order_by
  id: order_by
  idCard: order_by
  idMember: order_by
  mimeType: order_by
  name: order_by
  pos: order_by
  url: order_by
}
"""
order by min() on columns of table "attachments"
"""
input attachments_min_order_by {
  bytes: order_by
  date: order_by
  edgeColor: order_by
  fileName: order_by
  id: order_by
  idCard: order_by
  idMember: order_by
  mimeType: order_by
  name: order_by
  pos: order_by
  url: order_by
}
"""
on_conflict condition type for table "attachments"
"""
input attachments_on_conflict {
  constraint: attachments_constraint!
  update_columns: [attachments_update_column!]! = []
  where: attachments_bool_exp
}
"""
Ordering options when selecting data from "attachments".
"""
input attachments_order_by {
  bytes: order_by
  date: order_by
  edgeColor: order_by
  fileName: order_by
  id: order_by
  idCard: order_by
  idMember: order_by
  isUpload: order_by
  mimeType: order_by
  name: order_by
  pos: order_by
  url: order_by
}
"primary key columns input for table: attachments"
input attachments_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "attachments"
"""
input attachments_set_input {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String
  idCard: String
  idMember: String
  isUpload: Boolean
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"""
order by stddev() on columns of table "attachments"
"""
input attachments_stddev_order_by {
  bytes: order_by
  pos: order_by
}
"""
order by stddev_pop() on columns of table "attachments"
"""
input attachments_stddev_pop_order_by {
  bytes: order_by
  pos: order_by
}
"""
order by stddev_samp() on columns of table "attachments"
"""
input attachments_stddev_samp_order_by {
  bytes: order_by
  pos: order_by
}
"""
Streaming cursor of the table "attachments"
"""
input attachments_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attachments_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input attachments_stream_cursor_value_input {
  bytes: numeric
  date: timestamptz
  edgeColor: String
  fileName: String
  id: String
  idCard: String
  idMember: String
  isUpload: Boolean
  mimeType: String
  name: String
  pos: numeric
  url: String
}
"""
order by sum() on columns of table "attachments"
"""
input attachments_sum_order_by {
  bytes: order_by
  pos: order_by
}
input attachments_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: attachments_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: attachments_set_input
  "filter the rows which have to be updated"
  where: attachments_bool_exp!
}
"""
order by var_pop() on columns of table "attachments"
"""
input attachments_var_pop_order_by {
  bytes: order_by
  pos: order_by
}
"""
order by var_samp() on columns of table "attachments"
"""
input attachments_var_samp_order_by {
  bytes: order_by
  pos: order_by
}
"""
order by variance() on columns of table "attachments"
"""
input attachments_variance_order_by {
  bytes: order_by
  pos: order_by
}
"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}
"append existing jsonb value of filtered columns with new jsonb value"
input boardBackgrounds_append_input {
  attribution: jsonb
}
"""
Boolean expression to filter rows from the table "boardBackgrounds". All fields are combined with a logical 'AND'.
"""
input boardBackgrounds_bool_exp {
  _and: [boardBackgrounds_bool_exp!]
  _not: boardBackgrounds_bool_exp
  _or: [boardBackgrounds_bool_exp!]
  attribution: jsonb_comparison_exp
  bottomColor: String_comparison_exp
  brightness: String_comparison_exp
  color: String_comparison_exp
  emoji: String_comparison_exp
  fullSizeUrl: String_comparison_exp
  id: String_comparison_exp
  tile: Boolean_comparison_exp
  topColor: String_comparison_exp
  type: String_comparison_exp
}
"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input boardBackgrounds_delete_at_path_input {
  attribution: [String!]
}
"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input boardBackgrounds_delete_elem_input {
  attribution: Int
}
"delete key/value pair or string element. key/value pairs are matched based on their key value"
input boardBackgrounds_delete_key_input {
  attribution: String
}
"""
input type for inserting data into table "boardBackgrounds"
"""
input boardBackgrounds_insert_input {
  attribution: jsonb
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String
  tile: Boolean
  topColor: String
  type: String
}
"""
on_conflict condition type for table "boardBackgrounds"
"""
input boardBackgrounds_on_conflict {
  constraint: boardBackgrounds_constraint!
  update_columns: [boardBackgrounds_update_column!]! = []
  where: boardBackgrounds_bool_exp
}
"""
Ordering options when selecting data from "boardBackgrounds".
"""
input boardBackgrounds_order_by {
  attribution: order_by
  bottomColor: order_by
  brightness: order_by
  color: order_by
  emoji: order_by
  fullSizeUrl: order_by
  id: order_by
  tile: order_by
  topColor: order_by
  type: order_by
}
"primary key columns input for table: boardBackgrounds"
input boardBackgrounds_pk_columns_input {
  id: String!
}
"prepend existing jsonb value of filtered columns with new jsonb value"
input boardBackgrounds_prepend_input {
  attribution: jsonb
}
"""
input type for updating data in table "boardBackgrounds"
"""
input boardBackgrounds_set_input {
  attribution: jsonb
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String
  tile: Boolean
  topColor: String
  type: String
}
"""
Streaming cursor of the table "boardBackgrounds"
"""
input boardBackgrounds_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: boardBackgrounds_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input boardBackgrounds_stream_cursor_value_input {
  attribution: jsonb
  bottomColor: String
  brightness: String
  color: String
  emoji: String
  fullSizeUrl: String
  id: String
  tile: Boolean
  topColor: String
  type: String
}
input boardBackgrounds_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: boardBackgrounds_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: boardBackgrounds_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: boardBackgrounds_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: boardBackgrounds_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: boardBackgrounds_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: boardBackgrounds_set_input
  "filter the rows which have to be updated"
  where: boardBackgrounds_bool_exp!
}
"""
Boolean expression to filter rows from the table "boardPrefs". All fields are combined with a logical 'AND'.
"""
input boardPrefs_bool_exp {
  _and: [boardPrefs_bool_exp!]
  _not: boardPrefs_bool_exp
  _or: [boardPrefs_bool_exp!]
  background: String_comparison_exp
  backgroundBottomColor: String_comparison_exp
  backgroundBrightness: String_comparison_exp
  backgroundColor: String_comparison_exp
  backgroundImage: String_comparison_exp
  backgroundTile: Boolean_comparison_exp
  backgroundTopColor: String_comparison_exp
  calendarFeedEnabled: Boolean_comparison_exp
  canBeOrg: Boolean_comparison_exp
  canBePrivate: Boolean_comparison_exp
  canBePublic: Boolean_comparison_exp
  canInvite: Boolean_comparison_exp
  cardAging: String_comparison_exp
  cardCovers: Boolean_comparison_exp
  comments: String_comparison_exp
  hideVotes: Boolean_comparison_exp
  id: String_comparison_exp
  invitations: String_comparison_exp
  isTemplate: Boolean_comparison_exp
  permissionLevel: String_comparison_exp
  selfJoin: Boolean_comparison_exp
  voting: String_comparison_exp
}
"""
input type for inserting data into table "boardPrefs"
"""
input boardPrefs_insert_input {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTile: Boolean
  backgroundTopColor: String
  calendarFeedEnabled: Boolean
  canBeOrg: Boolean
  canBePrivate: Boolean
  canBePublic: Boolean
  canInvite: Boolean
  cardAging: String
  cardCovers: Boolean
  comments: String
  hideVotes: Boolean
  id: String
  invitations: String
  isTemplate: Boolean
  permissionLevel: String
  selfJoin: Boolean
  voting: String
}
"""
input type for inserting object relation for remote table "boardPrefs"
"""
input boardPrefs_obj_rel_insert_input {
  data: boardPrefs_insert_input!
  "upsert condition"
  on_conflict: boardPrefs_on_conflict
}
"""
on_conflict condition type for table "boardPrefs"
"""
input boardPrefs_on_conflict {
  constraint: boardPrefs_constraint!
  update_columns: [boardPrefs_update_column!]! = []
  where: boardPrefs_bool_exp
}
"""
Ordering options when selecting data from "boardPrefs".
"""
input boardPrefs_order_by {
  background: order_by
  backgroundBottomColor: order_by
  backgroundBrightness: order_by
  backgroundColor: order_by
  backgroundImage: order_by
  backgroundTile: order_by
  backgroundTopColor: order_by
  calendarFeedEnabled: order_by
  canBeOrg: order_by
  canBePrivate: order_by
  canBePublic: order_by
  canInvite: order_by
  cardAging: order_by
  cardCovers: order_by
  comments: order_by
  hideVotes: order_by
  id: order_by
  invitations: order_by
  isTemplate: order_by
  permissionLevel: order_by
  selfJoin: order_by
  voting: order_by
}
"primary key columns input for table: boardPrefs"
input boardPrefs_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "boardPrefs"
"""
input boardPrefs_set_input {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTile: Boolean
  backgroundTopColor: String
  calendarFeedEnabled: Boolean
  canBeOrg: Boolean
  canBePrivate: Boolean
  canBePublic: Boolean
  canInvite: Boolean
  cardAging: String
  cardCovers: Boolean
  comments: String
  hideVotes: Boolean
  id: String
  invitations: String
  isTemplate: Boolean
  permissionLevel: String
  selfJoin: Boolean
  voting: String
}
"""
Streaming cursor of the table "boardPrefs"
"""
input boardPrefs_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: boardPrefs_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input boardPrefs_stream_cursor_value_input {
  background: String
  backgroundBottomColor: String
  backgroundBrightness: String
  backgroundColor: String
  backgroundImage: String
  backgroundTile: Boolean
  backgroundTopColor: String
  calendarFeedEnabled: Boolean
  canBeOrg: Boolean
  canBePrivate: Boolean
  canBePublic: Boolean
  canInvite: Boolean
  cardAging: String
  cardCovers: Boolean
  comments: String
  hideVotes: Boolean
  id: String
  invitations: String
  isTemplate: Boolean
  permissionLevel: String
  selfJoin: Boolean
  voting: String
}
input boardPrefs_updates {
  "sets the columns of the filtered rows to the given values"
  _set: boardPrefs_set_input
  "filter the rows which have to be updated"
  where: boardPrefs_bool_exp!
}
input boardStars_aggregate_bool_exp {
  count: boardStars_aggregate_bool_exp_count
}
input boardStars_aggregate_bool_exp_count {
  arguments: [boardStars_select_column!]
  distinct: Boolean
  filter: boardStars_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "boardStars"
"""
input boardStars_aggregate_order_by {
  avg: boardStars_avg_order_by
  count: order_by
  max: boardStars_max_order_by
  min: boardStars_min_order_by
  stddev: boardStars_stddev_order_by
  stddev_pop: boardStars_stddev_pop_order_by
  stddev_samp: boardStars_stddev_samp_order_by
  sum: boardStars_sum_order_by
  var_pop: boardStars_var_pop_order_by
  var_samp: boardStars_var_samp_order_by
  variance: boardStars_variance_order_by
}
"""
input type for inserting array relation for remote table "boardStars"
"""
input boardStars_arr_rel_insert_input {
  data: [boardStars_insert_input!]!
  "upsert condition"
  on_conflict: boardStars_on_conflict
}
"""
order by avg() on columns of table "boardStars"
"""
input boardStars_avg_order_by {
  pos: order_by
}
"""
Boolean expression to filter rows from the table "boardStars". All fields are combined with a logical 'AND'.
"""
input boardStars_bool_exp {
  _and: [boardStars_bool_exp!]
  _not: boardStars_bool_exp
  _or: [boardStars_bool_exp!]
  id: String_comparison_exp
  idBoard: String_comparison_exp
  idMember: String_comparison_exp
  pos: numeric_comparison_exp
}
"""
input type for incrementing numeric columns in table "boardStars"
"""
input boardStars_inc_input {
  pos: numeric
}
"""
input type for inserting data into table "boardStars"
"""
input boardStars_insert_input {
  id: String
  idBoard: String
  idMember: String
  pos: numeric
}
"""
order by max() on columns of table "boardStars"
"""
input boardStars_max_order_by {
  id: order_by
  idBoard: order_by
  idMember: order_by
  pos: order_by
}
"""
order by min() on columns of table "boardStars"
"""
input boardStars_min_order_by {
  id: order_by
  idBoard: order_by
  idMember: order_by
  pos: order_by
}
"""
on_conflict condition type for table "boardStars"
"""
input boardStars_on_conflict {
  constraint: boardStars_constraint!
  update_columns: [boardStars_update_column!]! = []
  where: boardStars_bool_exp
}
"""
Ordering options when selecting data from "boardStars".
"""
input boardStars_order_by {
  id: order_by
  idBoard: order_by
  idMember: order_by
  pos: order_by
}
"primary key columns input for table: boardStars"
input boardStars_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "boardStars"
"""
input boardStars_set_input {
  id: String
  idBoard: String
  idMember: String
  pos: numeric
}
"""
order by stddev() on columns of table "boardStars"
"""
input boardStars_stddev_order_by {
  pos: order_by
}
"""
order by stddev_pop() on columns of table "boardStars"
"""
input boardStars_stddev_pop_order_by {
  pos: order_by
}
"""
order by stddev_samp() on columns of table "boardStars"
"""
input boardStars_stddev_samp_order_by {
  pos: order_by
}
"""
Streaming cursor of the table "boardStars"
"""
input boardStars_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: boardStars_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input boardStars_stream_cursor_value_input {
  id: String
  idBoard: String
  idMember: String
  pos: numeric
}
"""
order by sum() on columns of table "boardStars"
"""
input boardStars_sum_order_by {
  pos: order_by
}
input boardStars_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: boardStars_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: boardStars_set_input
  "filter the rows which have to be updated"
  where: boardStars_bool_exp!
}
"""
order by var_pop() on columns of table "boardStars"
"""
input boardStars_var_pop_order_by {
  pos: order_by
}
"""
order by var_samp() on columns of table "boardStars"
"""
input boardStars_var_samp_order_by {
  pos: order_by
}
"""
order by variance() on columns of table "boardStars"
"""
input boardStars_variance_order_by {
  pos: order_by
}
input boards_aggregate_bool_exp {
  bool_and: boards_aggregate_bool_exp_bool_and
  bool_or: boards_aggregate_bool_exp_bool_or
  count: boards_aggregate_bool_exp_count
}
input boards_aggregate_bool_exp_bool_and {
  arguments: boards_select_column_boards_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: boards_bool_exp
  predicate: Boolean_comparison_exp!
}
input boards_aggregate_bool_exp_bool_or {
  arguments: boards_select_column_boards_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: boards_bool_exp
  predicate: Boolean_comparison_exp!
}
input boards_aggregate_bool_exp_count {
  arguments: [boards_select_column!]
  distinct: Boolean
  filter: boards_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "boards"
"""
input boards_aggregate_order_by {
  count: order_by
  max: boards_max_order_by
  min: boards_min_order_by
}
"""
input type for inserting array relation for remote table "boards"
"""
input boards_arr_rel_insert_input {
  data: [boards_insert_input!]!
  "upsert condition"
  on_conflict: boards_on_conflict
}
"""
Boolean expression to filter rows from the table "boards". All fields are combined with a logical 'AND'.
"""
input boards_bool_exp {
  _and: [boards_bool_exp!]
  _not: boards_bool_exp
  _or: [boards_bool_exp!]
  closed: Boolean_comparison_exp
  dateClosed: timestamptz_comparison_exp
  desc: String_comparison_exp
  id: String_comparison_exp
  idMemberCreator: String_comparison_exp
  idOrganization: String_comparison_exp
  labels: labels_bool_exp
  labels_aggregate: labels_aggregate_bool_exp
  lists: lists_bool_exp
  lists_aggregate: lists_aggregate_bool_exp
  memberships: memberships_bool_exp
  memberships_aggregate: memberships_aggregate_bool_exp
  name: String_comparison_exp
  pinned: Boolean_comparison_exp
  prefs: boardPrefs_bool_exp
  shortUrl: String_comparison_exp
  url: String_comparison_exp
}
"""
input type for inserting data into table "boards"
"""
input boards_insert_input {
  closed: Boolean
  dateClosed: timestamptz
  desc: String
  id: String
  idMemberCreator: String
  idOrganization: String
  labels: labels_arr_rel_insert_input
  lists: lists_arr_rel_insert_input
  memberships: memberships_arr_rel_insert_input
  name: String
  pinned: Boolean
  prefs: boardPrefs_obj_rel_insert_input
  shortUrl: String
  url: String
}
"""
order by max() on columns of table "boards"
"""
input boards_max_order_by {
  dateClosed: order_by
  desc: order_by
  id: order_by
  idMemberCreator: order_by
  idOrganization: order_by
  name: order_by
  shortUrl: order_by
  url: order_by
}
"""
order by min() on columns of table "boards"
"""
input boards_min_order_by {
  dateClosed: order_by
  desc: order_by
  id: order_by
  idMemberCreator: order_by
  idOrganization: order_by
  name: order_by
  shortUrl: order_by
  url: order_by
}
"""
on_conflict condition type for table "boards"
"""
input boards_on_conflict {
  constraint: boards_constraint!
  update_columns: [boards_update_column!]! = []
  where: boards_bool_exp
}
"""
Ordering options when selecting data from "boards".
"""
input boards_order_by {
  closed: order_by
  dateClosed: order_by
  desc: order_by
  id: order_by
  idMemberCreator: order_by
  idOrganization: order_by
  labels_aggregate: labels_aggregate_order_by
  lists_aggregate: lists_aggregate_order_by
  memberships_aggregate: memberships_aggregate_order_by
  name: order_by
  pinned: order_by
  prefs: boardPrefs_order_by
  shortUrl: order_by
  url: order_by
}
"primary key columns input for table: boards"
input boards_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "boards"
"""
input boards_set_input {
  closed: Boolean
  dateClosed: timestamptz
  desc: String
  id: String
  idMemberCreator: String
  idOrganization: String
  name: String
  pinned: Boolean
  shortUrl: String
  url: String
}
"""
Streaming cursor of the table "boards"
"""
input boards_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: boards_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input boards_stream_cursor_value_input {
  closed: Boolean
  dateClosed: timestamptz
  desc: String
  id: String
  idMemberCreator: String
  idOrganization: String
  name: String
  pinned: Boolean
  shortUrl: String
  url: String
}
input boards_updates {
  "sets the columns of the filtered rows to the given values"
  _set: boards_set_input
  "filter the rows which have to be updated"
  where: boards_bool_exp!
}
"""
Boolean expression to filter rows from the table "cardBadges". All fields are combined with a logical 'AND'.
"""
input cardBadges_bool_exp {
  _and: [cardBadges_bool_exp!]
  _not: cardBadges_bool_exp
  _or: [cardBadges_bool_exp!]
  attachments: numeric_comparison_exp
  checkItems: numeric_comparison_exp
  checkItemsChecked: numeric_comparison_exp
  checkItemsEarliestdue: timestamptz_comparison_exp
  comments: numeric_comparison_exp
  description: Boolean_comparison_exp
  due: timestamptz_comparison_exp
  dueComplete: Boolean_comparison_exp
  fogbugz: String_comparison_exp
  id: String_comparison_exp
  location: Boolean_comparison_exp
  start: timestamptz_comparison_exp
  subscribed: Boolean_comparison_exp
  viewingMemberVoted: Boolean_comparison_exp
  votes: numeric_comparison_exp
}
"""
input type for incrementing numeric columns in table "cardBadges"
"""
input cardBadges_inc_input {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  comments: numeric
  votes: numeric
}
"""
input type for inserting data into table "cardBadges"
"""
input cardBadges_insert_input {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  description: Boolean
  due: timestamptz
  dueComplete: Boolean
  fogbugz: String
  id: String
  location: Boolean
  start: timestamptz
  subscribed: Boolean
  viewingMemberVoted: Boolean
  votes: numeric
}
"""
input type for inserting object relation for remote table "cardBadges"
"""
input cardBadges_obj_rel_insert_input {
  data: cardBadges_insert_input!
  "upsert condition"
  on_conflict: cardBadges_on_conflict
}
"""
on_conflict condition type for table "cardBadges"
"""
input cardBadges_on_conflict {
  constraint: cardBadges_constraint!
  update_columns: [cardBadges_update_column!]! = []
  where: cardBadges_bool_exp
}
"""
Ordering options when selecting data from "cardBadges".
"""
input cardBadges_order_by {
  attachments: order_by
  checkItems: order_by
  checkItemsChecked: order_by
  checkItemsEarliestdue: order_by
  comments: order_by
  description: order_by
  due: order_by
  dueComplete: order_by
  fogbugz: order_by
  id: order_by
  location: order_by
  start: order_by
  subscribed: order_by
  viewingMemberVoted: order_by
  votes: order_by
}
"primary key columns input for table: cardBadges"
input cardBadges_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cardBadges"
"""
input cardBadges_set_input {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  description: Boolean
  due: timestamptz
  dueComplete: Boolean
  fogbugz: String
  id: String
  location: Boolean
  start: timestamptz
  subscribed: Boolean
  viewingMemberVoted: Boolean
  votes: numeric
}
"""
Streaming cursor of the table "cardBadges"
"""
input cardBadges_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cardBadges_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cardBadges_stream_cursor_value_input {
  attachments: numeric
  checkItems: numeric
  checkItemsChecked: numeric
  checkItemsEarliestdue: timestamptz
  comments: numeric
  description: Boolean
  due: timestamptz
  dueComplete: Boolean
  fogbugz: String
  id: String
  location: Boolean
  start: timestamptz
  subscribed: Boolean
  viewingMemberVoted: Boolean
  votes: numeric
}
input cardBadges_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: cardBadges_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: cardBadges_set_input
  "filter the rows which have to be updated"
  where: cardBadges_bool_exp!
}
"""
Boolean expression to filter rows from the table "cardCovers". All fields are combined with a logical 'AND'.
"""
input cardCovers_bool_exp {
  _and: [cardCovers_bool_exp!]
  _not: cardCovers_bool_exp
  _or: [cardCovers_bool_exp!]
  brightness: String_comparison_exp
  color: String_comparison_exp
  id: String_comparison_exp
  idAttachment: String_comparison_exp
  size: String_comparison_exp
}
"""
input type for inserting data into table "cardCovers"
"""
input cardCovers_insert_input {
  brightness: String
  color: String
  id: String
  idAttachment: String
  size: String
}
"""
input type for inserting object relation for remote table "cardCovers"
"""
input cardCovers_obj_rel_insert_input {
  data: cardCovers_insert_input!
  "upsert condition"
  on_conflict: cardCovers_on_conflict
}
"""
on_conflict condition type for table "cardCovers"
"""
input cardCovers_on_conflict {
  constraint: cardCovers_constraint!
  update_columns: [cardCovers_update_column!]! = []
  where: cardCovers_bool_exp
}
"""
Ordering options when selecting data from "cardCovers".
"""
input cardCovers_order_by {
  brightness: order_by
  color: order_by
  id: order_by
  idAttachment: order_by
  size: order_by
}
"primary key columns input for table: cardCovers"
input cardCovers_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cardCovers"
"""
input cardCovers_set_input {
  brightness: String
  color: String
  id: String
  idAttachment: String
  size: String
}
"""
Streaming cursor of the table "cardCovers"
"""
input cardCovers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cardCovers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cardCovers_stream_cursor_value_input {
  brightness: String
  color: String
  id: String
  idAttachment: String
  size: String
}
input cardCovers_updates {
  "sets the columns of the filtered rows to the given values"
  _set: cardCovers_set_input
  "filter the rows which have to be updated"
  where: cardCovers_bool_exp!
}
input cardLabels_aggregate_bool_exp {
  count: cardLabels_aggregate_bool_exp_count
}
input cardLabels_aggregate_bool_exp_count {
  arguments: [cardLabels_select_column!]
  distinct: Boolean
  filter: cardLabels_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "cardLabels"
"""
input cardLabels_aggregate_order_by {
  count: order_by
  max: cardLabels_max_order_by
  min: cardLabels_min_order_by
}
"""
input type for inserting array relation for remote table "cardLabels"
"""
input cardLabels_arr_rel_insert_input {
  data: [cardLabels_insert_input!]!
  "upsert condition"
  on_conflict: cardLabels_on_conflict
}
"""
Boolean expression to filter rows from the table "cardLabels". All fields are combined with a logical 'AND'.
"""
input cardLabels_bool_exp {
  _and: [cardLabels_bool_exp!]
  _not: cardLabels_bool_exp
  _or: [cardLabels_bool_exp!]
  id: String_comparison_exp
  idLabel: String_comparison_exp
}
"""
input type for inserting data into table "cardLabels"
"""
input cardLabels_insert_input {
  id: String
  idLabel: String
}
"""
order by max() on columns of table "cardLabels"
"""
input cardLabels_max_order_by {
  id: order_by
  idLabel: order_by
}
"""
order by min() on columns of table "cardLabels"
"""
input cardLabels_min_order_by {
  id: order_by
  idLabel: order_by
}
"""
on_conflict condition type for table "cardLabels"
"""
input cardLabels_on_conflict {
  constraint: cardLabels_constraint!
  update_columns: [cardLabels_update_column!]! = []
  where: cardLabels_bool_exp
}
"""
Ordering options when selecting data from "cardLabels".
"""
input cardLabels_order_by {
  id: order_by
  idLabel: order_by
}
"primary key columns input for table: cardLabels"
input cardLabels_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cardLabels"
"""
input cardLabels_set_input {
  id: String
  idLabel: String
}
"""
Streaming cursor of the table "cardLabels"
"""
input cardLabels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cardLabels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cardLabels_stream_cursor_value_input {
  id: String
  idLabel: String
}
input cardLabels_updates {
  "sets the columns of the filtered rows to the given values"
  _set: cardLabels_set_input
  "filter the rows which have to be updated"
  where: cardLabels_bool_exp!
}
input cardMembersVoted_aggregate_bool_exp {
  count: cardMembersVoted_aggregate_bool_exp_count
}
input cardMembersVoted_aggregate_bool_exp_count {
  arguments: [cardMembersVoted_select_column!]
  distinct: Boolean
  filter: cardMembersVoted_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "cardMembersVoted"
"""
input cardMembersVoted_aggregate_order_by {
  count: order_by
  max: cardMembersVoted_max_order_by
  min: cardMembersVoted_min_order_by
}
"""
input type for inserting array relation for remote table "cardMembersVoted"
"""
input cardMembersVoted_arr_rel_insert_input {
  data: [cardMembersVoted_insert_input!]!
  "upsert condition"
  on_conflict: cardMembersVoted_on_conflict
}
"""
Boolean expression to filter rows from the table "cardMembersVoted". All fields are combined with a logical 'AND'.
"""
input cardMembersVoted_bool_exp {
  _and: [cardMembersVoted_bool_exp!]
  _not: cardMembersVoted_bool_exp
  _or: [cardMembersVoted_bool_exp!]
  id: String_comparison_exp
  idMember: String_comparison_exp
}
"""
input type for inserting data into table "cardMembersVoted"
"""
input cardMembersVoted_insert_input {
  id: String
  idMember: String
}
"""
order by max() on columns of table "cardMembersVoted"
"""
input cardMembersVoted_max_order_by {
  id: order_by
  idMember: order_by
}
"""
order by min() on columns of table "cardMembersVoted"
"""
input cardMembersVoted_min_order_by {
  id: order_by
  idMember: order_by
}
"""
on_conflict condition type for table "cardMembersVoted"
"""
input cardMembersVoted_on_conflict {
  constraint: cardMembersVoted_constraint!
  update_columns: [cardMembersVoted_update_column!]! = []
  where: cardMembersVoted_bool_exp
}
"""
Ordering options when selecting data from "cardMembersVoted".
"""
input cardMembersVoted_order_by {
  id: order_by
  idMember: order_by
}
"primary key columns input for table: cardMembersVoted"
input cardMembersVoted_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cardMembersVoted"
"""
input cardMembersVoted_set_input {
  id: String
  idMember: String
}
"""
Streaming cursor of the table "cardMembersVoted"
"""
input cardMembersVoted_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cardMembersVoted_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cardMembersVoted_stream_cursor_value_input {
  id: String
  idMember: String
}
input cardMembersVoted_updates {
  "sets the columns of the filtered rows to the given values"
  _set: cardMembersVoted_set_input
  "filter the rows which have to be updated"
  where: cardMembersVoted_bool_exp!
}
input cardMembers_aggregate_bool_exp {
  count: cardMembers_aggregate_bool_exp_count
}
input cardMembers_aggregate_bool_exp_count {
  arguments: [cardMembers_select_column!]
  distinct: Boolean
  filter: cardMembers_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "cardMembers"
"""
input cardMembers_aggregate_order_by {
  count: order_by
  max: cardMembers_max_order_by
  min: cardMembers_min_order_by
}
"""
input type for inserting array relation for remote table "cardMembers"
"""
input cardMembers_arr_rel_insert_input {
  data: [cardMembers_insert_input!]!
  "upsert condition"
  on_conflict: cardMembers_on_conflict
}
"""
Boolean expression to filter rows from the table "cardMembers". All fields are combined with a logical 'AND'.
"""
input cardMembers_bool_exp {
  _and: [cardMembers_bool_exp!]
  _not: cardMembers_bool_exp
  _or: [cardMembers_bool_exp!]
  id: String_comparison_exp
  idMember: String_comparison_exp
}
"""
input type for inserting data into table "cardMembers"
"""
input cardMembers_insert_input {
  id: String
  idMember: String
}
"""
order by max() on columns of table "cardMembers"
"""
input cardMembers_max_order_by {
  id: order_by
  idMember: order_by
}
"""
order by min() on columns of table "cardMembers"
"""
input cardMembers_min_order_by {
  id: order_by
  idMember: order_by
}
"""
on_conflict condition type for table "cardMembers"
"""
input cardMembers_on_conflict {
  constraint: cardMembers_constraint!
  update_columns: [cardMembers_update_column!]! = []
  where: cardMembers_bool_exp
}
"""
Ordering options when selecting data from "cardMembers".
"""
input cardMembers_order_by {
  id: order_by
  idMember: order_by
}
"primary key columns input for table: cardMembers"
input cardMembers_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cardMembers"
"""
input cardMembers_set_input {
  id: String
  idMember: String
}
"""
Streaming cursor of the table "cardMembers"
"""
input cardMembers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cardMembers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cardMembers_stream_cursor_value_input {
  id: String
  idMember: String
}
input cardMembers_updates {
  "sets the columns of the filtered rows to the given values"
  _set: cardMembers_set_input
  "filter the rows which have to be updated"
  where: cardMembers_bool_exp!
}
input cards_aggregate_bool_exp {
  bool_and: cards_aggregate_bool_exp_bool_and
  bool_or: cards_aggregate_bool_exp_bool_or
  count: cards_aggregate_bool_exp_count
}
input cards_aggregate_bool_exp_bool_and {
  arguments: cards_select_column_cards_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: cards_bool_exp
  predicate: Boolean_comparison_exp!
}
input cards_aggregate_bool_exp_bool_or {
  arguments: cards_select_column_cards_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: cards_bool_exp
  predicate: Boolean_comparison_exp!
}
input cards_aggregate_bool_exp_count {
  arguments: [cards_select_column!]
  distinct: Boolean
  filter: cards_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "cards"
"""
input cards_aggregate_order_by {
  avg: cards_avg_order_by
  count: order_by
  max: cards_max_order_by
  min: cards_min_order_by
  stddev: cards_stddev_order_by
  stddev_pop: cards_stddev_pop_order_by
  stddev_samp: cards_stddev_samp_order_by
  sum: cards_sum_order_by
  var_pop: cards_var_pop_order_by
  var_samp: cards_var_samp_order_by
  variance: cards_variance_order_by
}
"""
input type for inserting array relation for remote table "cards"
"""
input cards_arr_rel_insert_input {
  data: [cards_insert_input!]!
  "upsert condition"
  on_conflict: cards_on_conflict
}
"""
order by avg() on columns of table "cards"
"""
input cards_avg_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
Boolean expression to filter rows from the table "cards". All fields are combined with a logical 'AND'.
"""
input cards_bool_exp {
  _and: [cards_bool_exp!]
  _not: cards_bool_exp
  _or: [cards_bool_exp!]
  attachments: attachments_bool_exp
  attachments_aggregate: attachments_aggregate_bool_exp
  badges: cardBadges_bool_exp
  checklists: checklists_bool_exp
  checklists_aggregate: checklists_aggregate_bool_exp
  closed: Boolean_comparison_exp
  cover: cardCovers_bool_exp
  dateLastActivity: timestamptz_comparison_exp
  desc: String_comparison_exp
  due: timestamptz_comparison_exp
  dueComplete: Boolean_comparison_exp
  dueReminder: numeric_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  idBoard: String_comparison_exp
  idList: String_comparison_exp
  idShort: numeric_comparison_exp
  isTemplate: Boolean_comparison_exp
  labels: cardLabels_bool_exp
  labels_aggregate: cardLabels_aggregate_bool_exp
  manualCoverAttachment: Boolean_comparison_exp
  members: cardMembers_bool_exp
  membersVoted: cardMembersVoted_bool_exp
  membersVoted_aggregate: cardMembersVoted_aggregate_bool_exp
  members_aggregate: cardMembers_aggregate_bool_exp
  name: String_comparison_exp
  pos: numeric_comparison_exp
  shortLink: String_comparison_exp
  shortUrl: String_comparison_exp
  start: timestamptz_comparison_exp
  stickers: stickers_bool_exp
  stickers_aggregate: stickers_aggregate_bool_exp
  subscribed: Boolean_comparison_exp
  url: String_comparison_exp
}
"""
input type for incrementing numeric columns in table "cards"
"""
input cards_inc_input {
  dueReminder: numeric
  idShort: numeric
  pos: numeric
}
"""
input type for inserting data into table "cards"
"""
input cards_insert_input {
  attachments: attachments_arr_rel_insert_input
  badges: cardBadges_obj_rel_insert_input
  checklists: checklists_arr_rel_insert_input
  closed: Boolean
  cover: cardCovers_obj_rel_insert_input
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueComplete: Boolean
  dueReminder: numeric
  email: String
  id: String
  idBoard: String
  idList: String
  idShort: numeric
  isTemplate: Boolean
  labels: cardLabels_arr_rel_insert_input
  manualCoverAttachment: Boolean
  members: cardMembers_arr_rel_insert_input
  membersVoted: cardMembersVoted_arr_rel_insert_input
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  stickers: stickers_arr_rel_insert_input
  subscribed: Boolean
  url: String
}
"""
order by max() on columns of table "cards"
"""
input cards_max_order_by {
  dateLastActivity: order_by
  desc: order_by
  due: order_by
  dueReminder: order_by
  email: order_by
  id: order_by
  idBoard: order_by
  idList: order_by
  idShort: order_by
  name: order_by
  pos: order_by
  shortLink: order_by
  shortUrl: order_by
  start: order_by
  url: order_by
}
"""
order by min() on columns of table "cards"
"""
input cards_min_order_by {
  dateLastActivity: order_by
  desc: order_by
  due: order_by
  dueReminder: order_by
  email: order_by
  id: order_by
  idBoard: order_by
  idList: order_by
  idShort: order_by
  name: order_by
  pos: order_by
  shortLink: order_by
  shortUrl: order_by
  start: order_by
  url: order_by
}
"""
on_conflict condition type for table "cards"
"""
input cards_on_conflict {
  constraint: cards_constraint!
  update_columns: [cards_update_column!]! = []
  where: cards_bool_exp
}
"""
Ordering options when selecting data from "cards".
"""
input cards_order_by {
  attachments_aggregate: attachments_aggregate_order_by
  badges: cardBadges_order_by
  checklists_aggregate: checklists_aggregate_order_by
  closed: order_by
  cover: cardCovers_order_by
  dateLastActivity: order_by
  desc: order_by
  due: order_by
  dueComplete: order_by
  dueReminder: order_by
  email: order_by
  id: order_by
  idBoard: order_by
  idList: order_by
  idShort: order_by
  isTemplate: order_by
  labels_aggregate: cardLabels_aggregate_order_by
  manualCoverAttachment: order_by
  membersVoted_aggregate: cardMembersVoted_aggregate_order_by
  members_aggregate: cardMembers_aggregate_order_by
  name: order_by
  pos: order_by
  shortLink: order_by
  shortUrl: order_by
  start: order_by
  stickers_aggregate: stickers_aggregate_order_by
  subscribed: order_by
  url: order_by
}
"primary key columns input for table: cards"
input cards_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "cards"
"""
input cards_set_input {
  closed: Boolean
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueComplete: Boolean
  dueReminder: numeric
  email: String
  id: String
  idBoard: String
  idList: String
  idShort: numeric
  isTemplate: Boolean
  manualCoverAttachment: Boolean
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  subscribed: Boolean
  url: String
}
"""
order by stddev() on columns of table "cards"
"""
input cards_stddev_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
order by stddev_pop() on columns of table "cards"
"""
input cards_stddev_pop_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
order by stddev_samp() on columns of table "cards"
"""
input cards_stddev_samp_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
Streaming cursor of the table "cards"
"""
input cards_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: cards_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input cards_stream_cursor_value_input {
  closed: Boolean
  dateLastActivity: timestamptz
  desc: String
  due: timestamptz
  dueComplete: Boolean
  dueReminder: numeric
  email: String
  id: String
  idBoard: String
  idList: String
  idShort: numeric
  isTemplate: Boolean
  manualCoverAttachment: Boolean
  name: String
  pos: numeric
  shortLink: String
  shortUrl: String
  start: timestamptz
  subscribed: Boolean
  url: String
}
"""
order by sum() on columns of table "cards"
"""
input cards_sum_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
input cards_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: cards_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: cards_set_input
  "filter the rows which have to be updated"
  where: cards_bool_exp!
}
"""
order by var_pop() on columns of table "cards"
"""
input cards_var_pop_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
order by var_samp() on columns of table "cards"
"""
input cards_var_samp_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
"""
order by variance() on columns of table "cards"
"""
input cards_variance_order_by {
  dueReminder: order_by
  idShort: order_by
  pos: order_by
}
input checkItems_aggregate_bool_exp {
  count: checkItems_aggregate_bool_exp_count
}
input checkItems_aggregate_bool_exp_count {
  arguments: [checkItems_select_column!]
  distinct: Boolean
  filter: checkItems_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "checkItems"
"""
input checkItems_aggregate_order_by {
  avg: checkItems_avg_order_by
  count: order_by
  max: checkItems_max_order_by
  min: checkItems_min_order_by
  stddev: checkItems_stddev_order_by
  stddev_pop: checkItems_stddev_pop_order_by
  stddev_samp: checkItems_stddev_samp_order_by
  sum: checkItems_sum_order_by
  var_pop: checkItems_var_pop_order_by
  var_samp: checkItems_var_samp_order_by
  variance: checkItems_variance_order_by
}
"""
input type for inserting array relation for remote table "checkItems"
"""
input checkItems_arr_rel_insert_input {
  data: [checkItems_insert_input!]!
  "upsert condition"
  on_conflict: checkItems_on_conflict
}
"""
order by avg() on columns of table "checkItems"
"""
input checkItems_avg_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
Boolean expression to filter rows from the table "checkItems". All fields are combined with a logical 'AND'.
"""
input checkItems_bool_exp {
  _and: [checkItems_bool_exp!]
  _not: checkItems_bool_exp
  _or: [checkItems_bool_exp!]
  due: timestamptz_comparison_exp
  dueReminder: numeric_comparison_exp
  id: String_comparison_exp
  idChecklist: String_comparison_exp
  name: String_comparison_exp
  pos: numeric_comparison_exp
  state: String_comparison_exp
}
"""
input type for incrementing numeric columns in table "checkItems"
"""
input checkItems_inc_input {
  dueReminder: numeric
  pos: numeric
}
"""
input type for inserting data into table "checkItems"
"""
input checkItems_insert_input {
  due: timestamptz
  dueReminder: numeric
  id: String
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"""
order by max() on columns of table "checkItems"
"""
input checkItems_max_order_by {
  due: order_by
  dueReminder: order_by
  id: order_by
  idChecklist: order_by
  name: order_by
  pos: order_by
  state: order_by
}
"""
order by min() on columns of table "checkItems"
"""
input checkItems_min_order_by {
  due: order_by
  dueReminder: order_by
  id: order_by
  idChecklist: order_by
  name: order_by
  pos: order_by
  state: order_by
}
"""
on_conflict condition type for table "checkItems"
"""
input checkItems_on_conflict {
  constraint: checkItems_constraint!
  update_columns: [checkItems_update_column!]! = []
  where: checkItems_bool_exp
}
"""
Ordering options when selecting data from "checkItems".
"""
input checkItems_order_by {
  due: order_by
  dueReminder: order_by
  id: order_by
  idChecklist: order_by
  name: order_by
  pos: order_by
  state: order_by
}
"primary key columns input for table: checkItems"
input checkItems_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "checkItems"
"""
input checkItems_set_input {
  due: timestamptz
  dueReminder: numeric
  id: String
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"""
order by stddev() on columns of table "checkItems"
"""
input checkItems_stddev_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
order by stddev_pop() on columns of table "checkItems"
"""
input checkItems_stddev_pop_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
order by stddev_samp() on columns of table "checkItems"
"""
input checkItems_stddev_samp_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
Streaming cursor of the table "checkItems"
"""
input checkItems_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: checkItems_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input checkItems_stream_cursor_value_input {
  due: timestamptz
  dueReminder: numeric
  id: String
  idChecklist: String
  name: String
  pos: numeric
  state: String
}
"""
order by sum() on columns of table "checkItems"
"""
input checkItems_sum_order_by {
  dueReminder: order_by
  pos: order_by
}
input checkItems_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: checkItems_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: checkItems_set_input
  "filter the rows which have to be updated"
  where: checkItems_bool_exp!
}
"""
order by var_pop() on columns of table "checkItems"
"""
input checkItems_var_pop_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
order by var_samp() on columns of table "checkItems"
"""
input checkItems_var_samp_order_by {
  dueReminder: order_by
  pos: order_by
}
"""
order by variance() on columns of table "checkItems"
"""
input checkItems_variance_order_by {
  dueReminder: order_by
  pos: order_by
}
input checklists_aggregate_bool_exp {
  count: checklists_aggregate_bool_exp_count
}
input checklists_aggregate_bool_exp_count {
  arguments: [checklists_select_column!]
  distinct: Boolean
  filter: checklists_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "checklists"
"""
input checklists_aggregate_order_by {
  avg: checklists_avg_order_by
  count: order_by
  max: checklists_max_order_by
  min: checklists_min_order_by
  stddev: checklists_stddev_order_by
  stddev_pop: checklists_stddev_pop_order_by
  stddev_samp: checklists_stddev_samp_order_by
  sum: checklists_sum_order_by
  var_pop: checklists_var_pop_order_by
  var_samp: checklists_var_samp_order_by
  variance: checklists_variance_order_by
}
"""
input type for inserting array relation for remote table "checklists"
"""
input checklists_arr_rel_insert_input {
  data: [checklists_insert_input!]!
  "upsert condition"
  on_conflict: checklists_on_conflict
}
"""
order by avg() on columns of table "checklists"
"""
input checklists_avg_order_by {
  pos: order_by
}
"""
Boolean expression to filter rows from the table "checklists". All fields are combined with a logical 'AND'.
"""
input checklists_bool_exp {
  _and: [checklists_bool_exp!]
  _not: checklists_bool_exp
  _or: [checklists_bool_exp!]
  checkItems: checkItems_bool_exp
  checkItems_aggregate: checkItems_aggregate_bool_exp
  id: String_comparison_exp
  idCard: String_comparison_exp
  name: String_comparison_exp
  pos: numeric_comparison_exp
}
"""
input type for incrementing numeric columns in table "checklists"
"""
input checklists_inc_input {
  pos: numeric
}
"""
input type for inserting data into table "checklists"
"""
input checklists_insert_input {
  checkItems: checkItems_arr_rel_insert_input
  id: String
  idCard: String
  name: String
  pos: numeric
}
"""
order by max() on columns of table "checklists"
"""
input checklists_max_order_by {
  id: order_by
  idCard: order_by
  name: order_by
  pos: order_by
}
"""
order by min() on columns of table "checklists"
"""
input checklists_min_order_by {
  id: order_by
  idCard: order_by
  name: order_by
  pos: order_by
}
"""
on_conflict condition type for table "checklists"
"""
input checklists_on_conflict {
  constraint: checklists_constraint!
  update_columns: [checklists_update_column!]! = []
  where: checklists_bool_exp
}
"""
Ordering options when selecting data from "checklists".
"""
input checklists_order_by {
  checkItems_aggregate: checkItems_aggregate_order_by
  id: order_by
  idCard: order_by
  name: order_by
  pos: order_by
}
"primary key columns input for table: checklists"
input checklists_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "checklists"
"""
input checklists_set_input {
  id: String
  idCard: String
  name: String
  pos: numeric
}
"""
order by stddev() on columns of table "checklists"
"""
input checklists_stddev_order_by {
  pos: order_by
}
"""
order by stddev_pop() on columns of table "checklists"
"""
input checklists_stddev_pop_order_by {
  pos: order_by
}
"""
order by stddev_samp() on columns of table "checklists"
"""
input checklists_stddev_samp_order_by {
  pos: order_by
}
"""
Streaming cursor of the table "checklists"
"""
input checklists_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: checklists_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input checklists_stream_cursor_value_input {
  id: String
  idCard: String
  name: String
  pos: numeric
}
"""
order by sum() on columns of table "checklists"
"""
input checklists_sum_order_by {
  pos: order_by
}
input checklists_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: checklists_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: checklists_set_input
  "filter the rows which have to be updated"
  where: checklists_bool_exp!
}
"""
order by var_pop() on columns of table "checklists"
"""
input checklists_var_pop_order_by {
  pos: order_by
}
"""
order by var_samp() on columns of table "checklists"
"""
input checklists_var_samp_order_by {
  pos: order_by
}
"""
order by variance() on columns of table "checklists"
"""
input checklists_variance_order_by {
  pos: order_by
}
input customBoardBackgrounds_aggregate_bool_exp {
  bool_and: customBoardBackgrounds_aggregate_bool_exp_bool_and
  bool_or: customBoardBackgrounds_aggregate_bool_exp_bool_or
  count: customBoardBackgrounds_aggregate_bool_exp_count
}
input customBoardBackgrounds_aggregate_bool_exp_bool_and {
  arguments: customBoardBackgrounds_select_column_customBoardBackgrounds_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: customBoardBackgrounds_bool_exp
  predicate: Boolean_comparison_exp!
}
input customBoardBackgrounds_aggregate_bool_exp_bool_or {
  arguments: customBoardBackgrounds_select_column_customBoardBackgrounds_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: customBoardBackgrounds_bool_exp
  predicate: Boolean_comparison_exp!
}
input customBoardBackgrounds_aggregate_bool_exp_count {
  arguments: [customBoardBackgrounds_select_column!]
  distinct: Boolean
  filter: customBoardBackgrounds_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "customBoardBackgrounds"
"""
input customBoardBackgrounds_aggregate_order_by {
  count: order_by
  max: customBoardBackgrounds_max_order_by
  min: customBoardBackgrounds_min_order_by
}
"""
input type for inserting array relation for remote table "customBoardBackgrounds"
"""
input customBoardBackgrounds_arr_rel_insert_input {
  data: [customBoardBackgrounds_insert_input!]!
  "upsert condition"
  on_conflict: customBoardBackgrounds_on_conflict
}
"""
Boolean expression to filter rows from the table "customBoardBackgrounds". All fields are combined with a logical 'AND'.
"""
input customBoardBackgrounds_bool_exp {
  _and: [customBoardBackgrounds_bool_exp!]
  _not: customBoardBackgrounds_bool_exp
  _or: [customBoardBackgrounds_bool_exp!]
  bottomColor: String_comparison_exp
  brightness: String_comparison_exp
  fullSizeUrl: String_comparison_exp
  id: String_comparison_exp
  idMember: String_comparison_exp
  tile: Boolean_comparison_exp
  topColor: String_comparison_exp
  type: String_comparison_exp
}
"""
input type for inserting data into table "customBoardBackgrounds"
"""
input customBoardBackgrounds_insert_input {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String
  idMember: String
  tile: Boolean
  topColor: String
  type: String
}
"""
order by max() on columns of table "customBoardBackgrounds"
"""
input customBoardBackgrounds_max_order_by {
  bottomColor: order_by
  brightness: order_by
  fullSizeUrl: order_by
  id: order_by
  idMember: order_by
  topColor: order_by
  type: order_by
}
"""
order by min() on columns of table "customBoardBackgrounds"
"""
input customBoardBackgrounds_min_order_by {
  bottomColor: order_by
  brightness: order_by
  fullSizeUrl: order_by
  id: order_by
  idMember: order_by
  topColor: order_by
  type: order_by
}
"""
on_conflict condition type for table "customBoardBackgrounds"
"""
input customBoardBackgrounds_on_conflict {
  constraint: customBoardBackgrounds_constraint!
  update_columns: [customBoardBackgrounds_update_column!]! = []
  where: customBoardBackgrounds_bool_exp
}
"""
Ordering options when selecting data from "customBoardBackgrounds".
"""
input customBoardBackgrounds_order_by {
  bottomColor: order_by
  brightness: order_by
  fullSizeUrl: order_by
  id: order_by
  idMember: order_by
  tile: order_by
  topColor: order_by
  type: order_by
}
"primary key columns input for table: customBoardBackgrounds"
input customBoardBackgrounds_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "customBoardBackgrounds"
"""
input customBoardBackgrounds_set_input {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String
  idMember: String
  tile: Boolean
  topColor: String
  type: String
}
"""
Streaming cursor of the table "customBoardBackgrounds"
"""
input customBoardBackgrounds_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: customBoardBackgrounds_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input customBoardBackgrounds_stream_cursor_value_input {
  bottomColor: String
  brightness: String
  fullSizeUrl: String
  id: String
  idMember: String
  tile: Boolean
  topColor: String
  type: String
}
input customBoardBackgrounds_updates {
  "sets the columns of the filtered rows to the given values"
  _set: customBoardBackgrounds_set_input
  "filter the rows which have to be updated"
  where: customBoardBackgrounds_bool_exp!
}
input customEmojis_aggregate_bool_exp {
  count: customEmojis_aggregate_bool_exp_count
}
input customEmojis_aggregate_bool_exp_count {
  arguments: [customEmojis_select_column!]
  distinct: Boolean
  filter: customEmojis_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "customEmojis"
"""
input customEmojis_aggregate_order_by {
  count: order_by
  max: customEmojis_max_order_by
  min: customEmojis_min_order_by
}
"""
input type for inserting array relation for remote table "customEmojis"
"""
input customEmojis_arr_rel_insert_input {
  data: [customEmojis_insert_input!]!
  "upsert condition"
  on_conflict: customEmojis_on_conflict
}
"""
Boolean expression to filter rows from the table "customEmojis". All fields are combined with a logical 'AND'.
"""
input customEmojis_bool_exp {
  _and: [customEmojis_bool_exp!]
  _not: customEmojis_bool_exp
  _or: [customEmojis_bool_exp!]
  id: String_comparison_exp
  idMember: String_comparison_exp
  name: String_comparison_exp
  url: String_comparison_exp
}
"""
input type for inserting data into table "customEmojis"
"""
input customEmojis_insert_input {
  id: String
  idMember: String
  name: String
  url: String
}
"""
order by max() on columns of table "customEmojis"
"""
input customEmojis_max_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  url: order_by
}
"""
order by min() on columns of table "customEmojis"
"""
input customEmojis_min_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  url: order_by
}
"""
on_conflict condition type for table "customEmojis"
"""
input customEmojis_on_conflict {
  constraint: customEmojis_constraint!
  update_columns: [customEmojis_update_column!]! = []
  where: customEmojis_bool_exp
}
"""
Ordering options when selecting data from "customEmojis".
"""
input customEmojis_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  url: order_by
}
"primary key columns input for table: customEmojis"
input customEmojis_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "customEmojis"
"""
input customEmojis_set_input {
  id: String
  idMember: String
  name: String
  url: String
}
"""
Streaming cursor of the table "customEmojis"
"""
input customEmojis_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: customEmojis_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input customEmojis_stream_cursor_value_input {
  id: String
  idMember: String
  name: String
  url: String
}
input customEmojis_updates {
  "sets the columns of the filtered rows to the given values"
  _set: customEmojis_set_input
  "filter the rows which have to be updated"
  where: customEmojis_bool_exp!
}
input customStickers_aggregate_bool_exp {
  count: customStickers_aggregate_bool_exp_count
}
input customStickers_aggregate_bool_exp_count {
  arguments: [customStickers_select_column!]
  distinct: Boolean
  filter: customStickers_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "customStickers"
"""
input customStickers_aggregate_order_by {
  count: order_by
  max: customStickers_max_order_by
  min: customStickers_min_order_by
}
"""
input type for inserting array relation for remote table "customStickers"
"""
input customStickers_arr_rel_insert_input {
  data: [customStickers_insert_input!]!
  "upsert condition"
  on_conflict: customStickers_on_conflict
}
"""
Boolean expression to filter rows from the table "customStickers". All fields are combined with a logical 'AND'.
"""
input customStickers_bool_exp {
  _and: [customStickers_bool_exp!]
  _not: customStickers_bool_exp
  _or: [customStickers_bool_exp!]
  id: String_comparison_exp
  idMember: String_comparison_exp
  url: String_comparison_exp
}
"""
input type for inserting data into table "customStickers"
"""
input customStickers_insert_input {
  id: String
  idMember: String
  url: String
}
"""
order by max() on columns of table "customStickers"
"""
input customStickers_max_order_by {
  id: order_by
  idMember: order_by
  url: order_by
}
"""
order by min() on columns of table "customStickers"
"""
input customStickers_min_order_by {
  id: order_by
  idMember: order_by
  url: order_by
}
"""
on_conflict condition type for table "customStickers"
"""
input customStickers_on_conflict {
  constraint: customStickers_constraint!
  update_columns: [customStickers_update_column!]! = []
  where: customStickers_bool_exp
}
"""
Ordering options when selecting data from "customStickers".
"""
input customStickers_order_by {
  id: order_by
  idMember: order_by
  url: order_by
}
"primary key columns input for table: customStickers"
input customStickers_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "customStickers"
"""
input customStickers_set_input {
  id: String
  idMember: String
  url: String
}
"""
Streaming cursor of the table "customStickers"
"""
input customStickers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: customStickers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input customStickers_stream_cursor_value_input {
  id: String
  idMember: String
  url: String
}
input customStickers_updates {
  "sets the columns of the filtered rows to the given values"
  _set: customStickers_set_input
  "filter the rows which have to be updated"
  where: customStickers_bool_exp!
}
input jsonb_cast_exp {
  String: String_comparison_exp
}
"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}
input labels_aggregate_bool_exp {
  count: labels_aggregate_bool_exp_count
}
input labels_aggregate_bool_exp_count {
  arguments: [labels_select_column!]
  distinct: Boolean
  filter: labels_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "labels"
"""
input labels_aggregate_order_by {
  count: order_by
  max: labels_max_order_by
  min: labels_min_order_by
}
"""
input type for inserting array relation for remote table "labels"
"""
input labels_arr_rel_insert_input {
  data: [labels_insert_input!]!
  "upsert condition"
  on_conflict: labels_on_conflict
}
"""
Boolean expression to filter rows from the table "labels". All fields are combined with a logical 'AND'.
"""
input labels_bool_exp {
  _and: [labels_bool_exp!]
  _not: labels_bool_exp
  _or: [labels_bool_exp!]
  color: String_comparison_exp
  id: String_comparison_exp
  idBoard: String_comparison_exp
  name: String_comparison_exp
}
"""
input type for inserting data into table "labels"
"""
input labels_insert_input {
  color: String
  id: String
  idBoard: String
  name: String
}
"""
order by max() on columns of table "labels"
"""
input labels_max_order_by {
  color: order_by
  id: order_by
  idBoard: order_by
  name: order_by
}
"""
order by min() on columns of table "labels"
"""
input labels_min_order_by {
  color: order_by
  id: order_by
  idBoard: order_by
  name: order_by
}
"""
on_conflict condition type for table "labels"
"""
input labels_on_conflict {
  constraint: labels_constraint!
  update_columns: [labels_update_column!]! = []
  where: labels_bool_exp
}
"""
Ordering options when selecting data from "labels".
"""
input labels_order_by {
  color: order_by
  id: order_by
  idBoard: order_by
  name: order_by
}
"primary key columns input for table: labels"
input labels_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "labels"
"""
input labels_set_input {
  color: String
  id: String
  idBoard: String
  name: String
}
"""
Streaming cursor of the table "labels"
"""
input labels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: labels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input labels_stream_cursor_value_input {
  color: String
  id: String
  idBoard: String
  name: String
}
input labels_updates {
  "sets the columns of the filtered rows to the given values"
  _set: labels_set_input
  "filter the rows which have to be updated"
  where: labels_bool_exp!
}
input lists_aggregate_bool_exp {
  bool_and: lists_aggregate_bool_exp_bool_and
  bool_or: lists_aggregate_bool_exp_bool_or
  count: lists_aggregate_bool_exp_count
}
input lists_aggregate_bool_exp_bool_and {
  arguments: lists_select_column_lists_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: lists_bool_exp
  predicate: Boolean_comparison_exp!
}
input lists_aggregate_bool_exp_bool_or {
  arguments: lists_select_column_lists_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: lists_bool_exp
  predicate: Boolean_comparison_exp!
}
input lists_aggregate_bool_exp_count {
  arguments: [lists_select_column!]
  distinct: Boolean
  filter: lists_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "lists"
"""
input lists_aggregate_order_by {
  avg: lists_avg_order_by
  count: order_by
  max: lists_max_order_by
  min: lists_min_order_by
  stddev: lists_stddev_order_by
  stddev_pop: lists_stddev_pop_order_by
  stddev_samp: lists_stddev_samp_order_by
  sum: lists_sum_order_by
  var_pop: lists_var_pop_order_by
  var_samp: lists_var_samp_order_by
  variance: lists_variance_order_by
}
"""
input type for inserting array relation for remote table "lists"
"""
input lists_arr_rel_insert_input {
  data: [lists_insert_input!]!
  "upsert condition"
  on_conflict: lists_on_conflict
}
"""
order by avg() on columns of table "lists"
"""
input lists_avg_order_by {
  pos: order_by
}
"""
Boolean expression to filter rows from the table "lists". All fields are combined with a logical 'AND'.
"""
input lists_bool_exp {
  _and: [lists_bool_exp!]
  _not: lists_bool_exp
  _or: [lists_bool_exp!]
  cards: cards_bool_exp
  cards_aggregate: cards_aggregate_bool_exp
  closed: Boolean_comparison_exp
  id: String_comparison_exp
  idBoard: String_comparison_exp
  name: String_comparison_exp
  pos: numeric_comparison_exp
  softLimit: String_comparison_exp
  subscribed: Boolean_comparison_exp
}
"""
input type for incrementing numeric columns in table "lists"
"""
input lists_inc_input {
  pos: numeric
}
"""
input type for inserting data into table "lists"
"""
input lists_insert_input {
  cards: cards_arr_rel_insert_input
  closed: Boolean
  id: String
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
  subscribed: Boolean
}
"""
order by max() on columns of table "lists"
"""
input lists_max_order_by {
  id: order_by
  idBoard: order_by
  name: order_by
  pos: order_by
  softLimit: order_by
}
"""
order by min() on columns of table "lists"
"""
input lists_min_order_by {
  id: order_by
  idBoard: order_by
  name: order_by
  pos: order_by
  softLimit: order_by
}
"""
on_conflict condition type for table "lists"
"""
input lists_on_conflict {
  constraint: lists_constraint!
  update_columns: [lists_update_column!]! = []
  where: lists_bool_exp
}
"""
Ordering options when selecting data from "lists".
"""
input lists_order_by {
  cards_aggregate: cards_aggregate_order_by
  closed: order_by
  id: order_by
  idBoard: order_by
  name: order_by
  pos: order_by
  softLimit: order_by
  subscribed: order_by
}
"primary key columns input for table: lists"
input lists_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "lists"
"""
input lists_set_input {
  closed: Boolean
  id: String
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
  subscribed: Boolean
}
"""
order by stddev() on columns of table "lists"
"""
input lists_stddev_order_by {
  pos: order_by
}
"""
order by stddev_pop() on columns of table "lists"
"""
input lists_stddev_pop_order_by {
  pos: order_by
}
"""
order by stddev_samp() on columns of table "lists"
"""
input lists_stddev_samp_order_by {
  pos: order_by
}
"""
Streaming cursor of the table "lists"
"""
input lists_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: lists_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input lists_stream_cursor_value_input {
  closed: Boolean
  id: String
  idBoard: String
  name: String
  pos: numeric
  softLimit: String
  subscribed: Boolean
}
"""
order by sum() on columns of table "lists"
"""
input lists_sum_order_by {
  pos: order_by
}
input lists_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: lists_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: lists_set_input
  "filter the rows which have to be updated"
  where: lists_bool_exp!
}
"""
order by var_pop() on columns of table "lists"
"""
input lists_var_pop_order_by {
  pos: order_by
}
"""
order by var_samp() on columns of table "lists"
"""
input lists_var_samp_order_by {
  pos: order_by
}
"""
order by variance() on columns of table "lists"
"""
input lists_variance_order_by {
  pos: order_by
}
input memberOrganizations_aggregate_bool_exp {
  bool_and: memberOrganizations_aggregate_bool_exp_bool_and
  bool_or: memberOrganizations_aggregate_bool_exp_bool_or
  count: memberOrganizations_aggregate_bool_exp_count
}
input memberOrganizations_aggregate_bool_exp_bool_and {
  arguments: memberOrganizations_select_column_memberOrganizations_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: memberOrganizations_bool_exp
  predicate: Boolean_comparison_exp!
}
input memberOrganizations_aggregate_bool_exp_bool_or {
  arguments: memberOrganizations_select_column_memberOrganizations_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: memberOrganizations_bool_exp
  predicate: Boolean_comparison_exp!
}
input memberOrganizations_aggregate_bool_exp_count {
  arguments: [memberOrganizations_select_column!]
  distinct: Boolean
  filter: memberOrganizations_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "memberOrganizations"
"""
input memberOrganizations_aggregate_order_by {
  avg: memberOrganizations_avg_order_by
  count: order_by
  max: memberOrganizations_max_order_by
  min: memberOrganizations_min_order_by
  stddev: memberOrganizations_stddev_order_by
  stddev_pop: memberOrganizations_stddev_pop_order_by
  stddev_samp: memberOrganizations_stddev_samp_order_by
  sum: memberOrganizations_sum_order_by
  var_pop: memberOrganizations_var_pop_order_by
  var_samp: memberOrganizations_var_samp_order_by
  variance: memberOrganizations_variance_order_by
}
"""
input type for inserting array relation for remote table "memberOrganizations"
"""
input memberOrganizations_arr_rel_insert_input {
  data: [memberOrganizations_insert_input!]!
}
"""
order by avg() on columns of table "memberOrganizations"
"""
input memberOrganizations_avg_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
Boolean expression to filter rows from the table "memberOrganizations". All fields are combined with a logical 'AND'.
"""
input memberOrganizations_bool_exp {
  _and: [memberOrganizations_bool_exp!]
  _not: memberOrganizations_bool_exp
  _or: [memberOrganizations_bool_exp!]
  billableCollaboratorCount: numeric_comparison_exp
  billableMemberCount: numeric_comparison_exp
  creationMethod: String_comparison_exp
  dateLastActivity: timestamptz_comparison_exp
  desc: String_comparison_exp
  displayName: String_comparison_exp
  id: String_comparison_exp
  idMember: String_comparison_exp
  idMemberCreator: String_comparison_exp
  invited: Boolean_comparison_exp
  ixUpdate: String_comparison_exp
  logoHash: String_comparison_exp
  logoUrl: String_comparison_exp
  membersCount: numeric_comparison_exp
  name: String_comparison_exp
  premiumFeatures: jsonb_comparison_exp
  url: String_comparison_exp
  website: String_comparison_exp
}
"""
input type for inserting data into table "memberOrganizations"
"""
input memberOrganizations_insert_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMember: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  premiumFeatures: jsonb
  url: String
  website: String
}
"""
order by max() on columns of table "memberOrganizations"
"""
input memberOrganizations_max_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  creationMethod: order_by
  dateLastActivity: order_by
  desc: order_by
  displayName: order_by
  id: order_by
  idMember: order_by
  idMemberCreator: order_by
  ixUpdate: order_by
  logoHash: order_by
  logoUrl: order_by
  membersCount: order_by
  name: order_by
  url: order_by
  website: order_by
}
"""
order by min() on columns of table "memberOrganizations"
"""
input memberOrganizations_min_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  creationMethod: order_by
  dateLastActivity: order_by
  desc: order_by
  displayName: order_by
  id: order_by
  idMember: order_by
  idMemberCreator: order_by
  ixUpdate: order_by
  logoHash: order_by
  logoUrl: order_by
  membersCount: order_by
  name: order_by
  url: order_by
  website: order_by
}
"""
Ordering options when selecting data from "memberOrganizations".
"""
input memberOrganizations_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  creationMethod: order_by
  dateLastActivity: order_by
  desc: order_by
  displayName: order_by
  id: order_by
  idMember: order_by
  idMemberCreator: order_by
  invited: order_by
  ixUpdate: order_by
  logoHash: order_by
  logoUrl: order_by
  membersCount: order_by
  name: order_by
  premiumFeatures: order_by
  url: order_by
  website: order_by
}
"""
order by stddev() on columns of table "memberOrganizations"
"""
input memberOrganizations_stddev_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
order by stddev_pop() on columns of table "memberOrganizations"
"""
input memberOrganizations_stddev_pop_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
order by stddev_samp() on columns of table "memberOrganizations"
"""
input memberOrganizations_stddev_samp_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
Streaming cursor of the table "memberOrganizations"
"""
input memberOrganizations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: memberOrganizations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input memberOrganizations_stream_cursor_value_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMember: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  premiumFeatures: jsonb
  url: String
  website: String
}
"""
order by sum() on columns of table "memberOrganizations"
"""
input memberOrganizations_sum_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
order by var_pop() on columns of table "memberOrganizations"
"""
input memberOrganizations_var_pop_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
order by var_samp() on columns of table "memberOrganizations"
"""
input memberOrganizations_var_samp_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
order by variance() on columns of table "memberOrganizations"
"""
input memberOrganizations_variance_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  membersCount: order_by
}
"""
Boolean expression to filter rows from the table "memberPrefs". All fields are combined with a logical 'AND'.
"""
input memberPrefs_bool_exp {
  _and: [memberPrefs_bool_exp!]
  _not: memberPrefs_bool_exp
  _or: [memberPrefs_bool_exp!]
  colorBlind: Boolean_comparison_exp
  id: String_comparison_exp
  locale: String_comparison_exp
  minutesBeforeDeadlineToNotify: numeric_comparison_exp
  minutesBetweenSummaries: numeric_comparison_exp
  sendSummaries: Boolean_comparison_exp
}
"""
input type for incrementing numeric columns in table "memberPrefs"
"""
input memberPrefs_inc_input {
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
}
"""
input type for inserting data into table "memberPrefs"
"""
input memberPrefs_insert_input {
  colorBlind: Boolean
  id: String
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
  sendSummaries: Boolean
}
"""
input type for inserting object relation for remote table "memberPrefs"
"""
input memberPrefs_obj_rel_insert_input {
  data: memberPrefs_insert_input!
  "upsert condition"
  on_conflict: memberPrefs_on_conflict
}
"""
on_conflict condition type for table "memberPrefs"
"""
input memberPrefs_on_conflict {
  constraint: memberPrefs_constraint!
  update_columns: [memberPrefs_update_column!]! = []
  where: memberPrefs_bool_exp
}
"""
Ordering options when selecting data from "memberPrefs".
"""
input memberPrefs_order_by {
  colorBlind: order_by
  id: order_by
  locale: order_by
  minutesBeforeDeadlineToNotify: order_by
  minutesBetweenSummaries: order_by
  sendSummaries: order_by
}
"primary key columns input for table: memberPrefs"
input memberPrefs_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "memberPrefs"
"""
input memberPrefs_set_input {
  colorBlind: Boolean
  id: String
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
  sendSummaries: Boolean
}
"""
Streaming cursor of the table "memberPrefs"
"""
input memberPrefs_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: memberPrefs_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input memberPrefs_stream_cursor_value_input {
  colorBlind: Boolean
  id: String
  locale: String
  minutesBeforeDeadlineToNotify: numeric
  minutesBetweenSummaries: numeric
  sendSummaries: Boolean
}
input memberPrefs_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: memberPrefs_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: memberPrefs_set_input
  "filter the rows which have to be updated"
  where: memberPrefs_bool_exp!
}
"append existing jsonb value of filtered columns with new jsonb value"
input members_append_input {
  loginTypes: jsonb
  oneTimeMessagesDismissed: jsonb
  premiumFeatures: jsonb
}
"""
Boolean expression to filter rows from the table "members". All fields are combined with a logical 'AND'.
"""
input members_bool_exp {
  _and: [members_bool_exp!]
  _not: members_bool_exp
  _or: [members_bool_exp!]
  activityBlocked: Boolean_comparison_exp
  avatarHash: String_comparison_exp
  avatarSource: String_comparison_exp
  avatarUrl: String_comparison_exp
  bio: String_comparison_exp
  boardStars: boardStars_bool_exp
  boardStars_aggregate: boardStars_aggregate_bool_exp
  boards: memberships_bool_exp
  boards_aggregate: memberships_aggregate_bool_exp
  confirmed: Boolean_comparison_exp
  credentialsRemovedCount: numeric_comparison_exp
  customBoardBackgrounds: customBoardBackgrounds_bool_exp
  customBoardBackgrounds_aggregate: customBoardBackgrounds_aggregate_bool_exp
  customEmojis: customEmojis_bool_exp
  customEmojis_aggregate: customEmojis_aggregate_bool_exp
  customStickers: customStickers_bool_exp
  customStickers_aggregate: customStickers_aggregate_bool_exp
  email: String_comparison_exp
  fullName: String_comparison_exp
  gravatarHash: String_comparison_exp
  id: String_comparison_exp
  idMemberReferrer: String_comparison_exp
  initials: String_comparison_exp
  ixUpdate: String_comparison_exp
  loginTypes: jsonb_comparison_exp
  memberType: String_comparison_exp
  nonPublicAvailable: Boolean_comparison_exp
  oneTimeMessagesDismissed: jsonb_comparison_exp
  organizations: memberOrganizations_bool_exp
  organizations_aggregate: memberOrganizations_aggregate_bool_exp
  prefs: memberPrefs_bool_exp
  premiumFeatures: jsonb_comparison_exp
  savedSearches: savedSearches_bool_exp
  savedSearches_aggregate: savedSearches_aggregate_bool_exp
  status: String_comparison_exp
  tokens: tokens_bool_exp
  tokens_aggregate: tokens_aggregate_bool_exp
  uploadedAvatarHash: String_comparison_exp
  uploadedAvatarUrl: String_comparison_exp
  url: String_comparison_exp
  username: String_comparison_exp
}
"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input members_delete_at_path_input {
  loginTypes: [String!]
  oneTimeMessagesDismissed: [String!]
  premiumFeatures: [String!]
}
"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input members_delete_elem_input {
  loginTypes: Int
  oneTimeMessagesDismissed: Int
  premiumFeatures: Int
}
"delete key/value pair or string element. key/value pairs are matched based on their key value"
input members_delete_key_input {
  loginTypes: String
  oneTimeMessagesDismissed: String
  premiumFeatures: String
}
"""
input type for incrementing numeric columns in table "members"
"""
input members_inc_input {
  credentialsRemovedCount: numeric
}
"""
input type for inserting data into table "members"
"""
input members_insert_input {
  activityBlocked: Boolean
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  boardStars: boardStars_arr_rel_insert_input
  boards: memberships_arr_rel_insert_input
  confirmed: Boolean
  credentialsRemovedCount: numeric
  customBoardBackgrounds: customBoardBackgrounds_arr_rel_insert_input
  customEmojis: customEmojis_arr_rel_insert_input
  customStickers: customStickers_arr_rel_insert_input
  email: String
  fullName: String
  gravatarHash: String
  id: String
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  loginTypes: jsonb
  memberType: String
  nonPublicAvailable: Boolean
  oneTimeMessagesDismissed: jsonb
  organizations: memberOrganizations_arr_rel_insert_input
  prefs: memberPrefs_obj_rel_insert_input
  premiumFeatures: jsonb
  savedSearches: savedSearches_arr_rel_insert_input
  status: String
  tokens: tokens_arr_rel_insert_input
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
"""
on_conflict condition type for table "members"
"""
input members_on_conflict {
  constraint: members_constraint!
  update_columns: [members_update_column!]! = []
  where: members_bool_exp
}
"""
Ordering options when selecting data from "members".
"""
input members_order_by {
  activityBlocked: order_by
  avatarHash: order_by
  avatarSource: order_by
  avatarUrl: order_by
  bio: order_by
  boardStars_aggregate: boardStars_aggregate_order_by
  boards_aggregate: memberships_aggregate_order_by
  confirmed: order_by
  credentialsRemovedCount: order_by
  customBoardBackgrounds_aggregate: customBoardBackgrounds_aggregate_order_by
  customEmojis_aggregate: customEmojis_aggregate_order_by
  customStickers_aggregate: customStickers_aggregate_order_by
  email: order_by
  fullName: order_by
  gravatarHash: order_by
  id: order_by
  idMemberReferrer: order_by
  initials: order_by
  ixUpdate: order_by
  loginTypes: order_by
  memberType: order_by
  nonPublicAvailable: order_by
  oneTimeMessagesDismissed: order_by
  organizations_aggregate: memberOrganizations_aggregate_order_by
  prefs: memberPrefs_order_by
  premiumFeatures: order_by
  savedSearches_aggregate: savedSearches_aggregate_order_by
  status: order_by
  tokens_aggregate: tokens_aggregate_order_by
  uploadedAvatarHash: order_by
  uploadedAvatarUrl: order_by
  url: order_by
  username: order_by
}
"primary key columns input for table: members"
input members_pk_columns_input {
  id: String!
}
"prepend existing jsonb value of filtered columns with new jsonb value"
input members_prepend_input {
  loginTypes: jsonb
  oneTimeMessagesDismissed: jsonb
  premiumFeatures: jsonb
}
"""
input type for updating data in table "members"
"""
input members_set_input {
  activityBlocked: Boolean
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  confirmed: Boolean
  credentialsRemovedCount: numeric
  email: String
  fullName: String
  gravatarHash: String
  id: String
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  loginTypes: jsonb
  memberType: String
  nonPublicAvailable: Boolean
  oneTimeMessagesDismissed: jsonb
  premiumFeatures: jsonb
  status: String
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
"""
Streaming cursor of the table "members"
"""
input members_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: members_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input members_stream_cursor_value_input {
  activityBlocked: Boolean
  avatarHash: String
  avatarSource: String
  avatarUrl: String
  bio: String
  confirmed: Boolean
  credentialsRemovedCount: numeric
  email: String
  fullName: String
  gravatarHash: String
  id: String
  idMemberReferrer: String
  initials: String
  ixUpdate: String
  loginTypes: jsonb
  memberType: String
  nonPublicAvailable: Boolean
  oneTimeMessagesDismissed: jsonb
  premiumFeatures: jsonb
  status: String
  uploadedAvatarHash: String
  uploadedAvatarUrl: String
  url: String
  username: String
}
input members_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: members_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: members_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: members_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: members_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: members_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: members_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: members_set_input
  "filter the rows which have to be updated"
  where: members_bool_exp!
}
input memberships_aggregate_bool_exp {
  bool_and: memberships_aggregate_bool_exp_bool_and
  bool_or: memberships_aggregate_bool_exp_bool_or
  count: memberships_aggregate_bool_exp_count
}
input memberships_aggregate_bool_exp_bool_and {
  arguments: memberships_select_column_memberships_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: memberships_bool_exp
  predicate: Boolean_comparison_exp!
}
input memberships_aggregate_bool_exp_bool_or {
  arguments: memberships_select_column_memberships_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: memberships_bool_exp
  predicate: Boolean_comparison_exp!
}
input memberships_aggregate_bool_exp_count {
  arguments: [memberships_select_column!]
  distinct: Boolean
  filter: memberships_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "memberships"
"""
input memberships_aggregate_order_by {
  count: order_by
  max: memberships_max_order_by
  min: memberships_min_order_by
}
"""
input type for inserting array relation for remote table "memberships"
"""
input memberships_arr_rel_insert_input {
  data: [memberships_insert_input!]!
  "upsert condition"
  on_conflict: memberships_on_conflict
}
"""
Boolean expression to filter rows from the table "memberships". All fields are combined with a logical 'AND'.
"""
input memberships_bool_exp {
  _and: [memberships_bool_exp!]
  _not: memberships_bool_exp
  _or: [memberships_bool_exp!]
  deactivated: Boolean_comparison_exp
  id: String_comparison_exp
  idBoard: String_comparison_exp
  idMember: String_comparison_exp
  memberType: String_comparison_exp
  unconfirmed: Boolean_comparison_exp
}
"""
input type for inserting data into table "memberships"
"""
input memberships_insert_input {
  deactivated: Boolean
  id: String
  idBoard: String
  idMember: String
  memberType: String
  unconfirmed: Boolean
}
"""
order by max() on columns of table "memberships"
"""
input memberships_max_order_by {
  id: order_by
  idBoard: order_by
  idMember: order_by
  memberType: order_by
}
"""
order by min() on columns of table "memberships"
"""
input memberships_min_order_by {
  id: order_by
  idBoard: order_by
  idMember: order_by
  memberType: order_by
}
"""
on_conflict condition type for table "memberships"
"""
input memberships_on_conflict {
  constraint: memberships_constraint!
  update_columns: [memberships_update_column!]! = []
  where: memberships_bool_exp
}
"""
Ordering options when selecting data from "memberships".
"""
input memberships_order_by {
  deactivated: order_by
  id: order_by
  idBoard: order_by
  idMember: order_by
  memberType: order_by
  unconfirmed: order_by
}
"primary key columns input for table: memberships"
input memberships_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "memberships"
"""
input memberships_set_input {
  deactivated: Boolean
  id: String
  idBoard: String
  idMember: String
  memberType: String
  unconfirmed: Boolean
}
"""
Streaming cursor of the table "memberships"
"""
input memberships_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: memberships_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input memberships_stream_cursor_value_input {
  deactivated: Boolean
  id: String
  idBoard: String
  idMember: String
  memberType: String
  unconfirmed: Boolean
}
input memberships_updates {
  "sets the columns of the filtered rows to the given values"
  _set: memberships_set_input
  "filter the rows which have to be updated"
  where: memberships_bool_exp!
}
"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  data: String_comparison_exp
  date: timestamptz_comparison_exp
  dateRead: timestamptz_comparison_exp
  id: String_comparison_exp
  idAction: String_comparison_exp
  idCard: String_comparison_exp
  idMemberCreator: String_comparison_exp
  type: String_comparison_exp
  unread: Boolean_comparison_exp
}
"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
  unread: Boolean
}
"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}
"""
Ordering options when selecting data from "notifications".
"""
input notifications_order_by {
  data: order_by
  date: order_by
  dateRead: order_by
  id: order_by
  idAction: order_by
  idCard: order_by
  idMemberCreator: order_by
  type: order_by
  unread: order_by
}
"primary key columns input for table: notifications"
input notifications_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
  unread: Boolean
}
"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: notifications_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input notifications_stream_cursor_value_input {
  data: String
  date: timestamptz
  dateRead: timestamptz
  id: String
  idAction: String
  idCard: String
  idMemberCreator: String
  type: String
  unread: Boolean
}
input notifications_updates {
  "sets the columns of the filtered rows to the given values"
  _set: notifications_set_input
  "filter the rows which have to be updated"
  where: notifications_bool_exp!
}
"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}
input organizationMemberships_aggregate_bool_exp {
  bool_and: organizationMemberships_aggregate_bool_exp_bool_and
  bool_or: organizationMemberships_aggregate_bool_exp_bool_or
  count: organizationMemberships_aggregate_bool_exp_count
}
input organizationMemberships_aggregate_bool_exp_bool_and {
  arguments: organizationMemberships_select_column_organizationMemberships_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: organizationMemberships_bool_exp
  predicate: Boolean_comparison_exp!
}
input organizationMemberships_aggregate_bool_exp_bool_or {
  arguments: organizationMemberships_select_column_organizationMemberships_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: organizationMemberships_bool_exp
  predicate: Boolean_comparison_exp!
}
input organizationMemberships_aggregate_bool_exp_count {
  arguments: [organizationMemberships_select_column!]
  distinct: Boolean
  filter: organizationMemberships_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "organizationMemberships"
"""
input organizationMemberships_aggregate_order_by {
  count: order_by
  max: organizationMemberships_max_order_by
  min: organizationMemberships_min_order_by
}
"""
input type for inserting array relation for remote table "organizationMemberships"
"""
input organizationMemberships_arr_rel_insert_input {
  data: [organizationMemberships_insert_input!]!
}
"""
Boolean expression to filter rows from the table "organizationMemberships". All fields are combined with a logical 'AND'.
"""
input organizationMemberships_bool_exp {
  _and: [organizationMemberships_bool_exp!]
  _not: organizationMemberships_bool_exp
  _or: [organizationMemberships_bool_exp!]
  deactivated: Boolean_comparison_exp
  id: String_comparison_exp
  idMember: String_comparison_exp
  idOrganization: String_comparison_exp
  memberType: String_comparison_exp
  unconfirmed: Boolean_comparison_exp
}
"""
input type for inserting data into table "organizationMemberships"
"""
input organizationMemberships_insert_input {
  deactivated: Boolean
  id: String
  idMember: String
  idOrganization: String
  memberType: String
  unconfirmed: Boolean
}
"""
order by max() on columns of table "organizationMemberships"
"""
input organizationMemberships_max_order_by {
  id: order_by
  idMember: order_by
  idOrganization: order_by
  memberType: order_by
}
"""
order by min() on columns of table "organizationMemberships"
"""
input organizationMemberships_min_order_by {
  id: order_by
  idMember: order_by
  idOrganization: order_by
  memberType: order_by
}
"""
Ordering options when selecting data from "organizationMemberships".
"""
input organizationMemberships_order_by {
  deactivated: order_by
  id: order_by
  idMember: order_by
  idOrganization: order_by
  memberType: order_by
  unconfirmed: order_by
}
"""
Streaming cursor of the table "organizationMemberships"
"""
input organizationMemberships_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: organizationMemberships_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input organizationMemberships_stream_cursor_value_input {
  deactivated: Boolean
  id: String
  idMember: String
  idOrganization: String
  memberType: String
  unconfirmed: Boolean
}
"""
Boolean expression to filter rows from the table "organizationPrefs". All fields are combined with a logical 'AND'.
"""
input organizationPrefs_bool_exp {
  _and: [organizationPrefs_bool_exp!]
  _not: organizationPrefs_bool_exp
  _or: [organizationPrefs_bool_exp!]
  associatedDomain: String_comparison_exp
  boardInviteRestrict: String_comparison_exp
  externalMembersDisabled: Boolean_comparison_exp
  googleAppsVersion: numeric_comparison_exp
  id: String_comparison_exp
  permissionLevel: String_comparison_exp
}
"""
input type for incrementing numeric columns in table "organizationPrefs"
"""
input organizationPrefs_inc_input {
  googleAppsVersion: numeric
}
"""
input type for inserting data into table "organizationPrefs"
"""
input organizationPrefs_insert_input {
  associatedDomain: String
  boardInviteRestrict: String
  externalMembersDisabled: Boolean
  googleAppsVersion: numeric
  id: String
  permissionLevel: String
}
"""
input type for inserting object relation for remote table "organizationPrefs"
"""
input organizationPrefs_obj_rel_insert_input {
  data: organizationPrefs_insert_input!
  "upsert condition"
  on_conflict: organizationPrefs_on_conflict
}
"""
on_conflict condition type for table "organizationPrefs"
"""
input organizationPrefs_on_conflict {
  constraint: organizationPrefs_constraint!
  update_columns: [organizationPrefs_update_column!]! = []
  where: organizationPrefs_bool_exp
}
"""
Ordering options when selecting data from "organizationPrefs".
"""
input organizationPrefs_order_by {
  associatedDomain: order_by
  boardInviteRestrict: order_by
  externalMembersDisabled: order_by
  googleAppsVersion: order_by
  id: order_by
  permissionLevel: order_by
}
"primary key columns input for table: organizationPrefs"
input organizationPrefs_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "organizationPrefs"
"""
input organizationPrefs_set_input {
  associatedDomain: String
  boardInviteRestrict: String
  externalMembersDisabled: Boolean
  googleAppsVersion: numeric
  id: String
  permissionLevel: String
}
"""
Streaming cursor of the table "organizationPrefs"
"""
input organizationPrefs_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: organizationPrefs_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input organizationPrefs_stream_cursor_value_input {
  associatedDomain: String
  boardInviteRestrict: String
  externalMembersDisabled: Boolean
  googleAppsVersion: numeric
  id: String
  permissionLevel: String
}
input organizationPrefs_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: organizationPrefs_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: organizationPrefs_set_input
  "filter the rows which have to be updated"
  where: organizationPrefs_bool_exp!
}
"append existing jsonb value of filtered columns with new jsonb value"
input organizations_append_input {
  premiumFeatures: jsonb
}
"""
Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'.
"""
input organizations_bool_exp {
  _and: [organizations_bool_exp!]
  _not: organizations_bool_exp
  _or: [organizations_bool_exp!]
  billableCollaboratorCount: numeric_comparison_exp
  billableMemberCount: numeric_comparison_exp
  boards: boards_bool_exp
  boards_aggregate: boards_aggregate_bool_exp
  creationMethod: String_comparison_exp
  dateLastActivity: timestamptz_comparison_exp
  desc: String_comparison_exp
  displayName: String_comparison_exp
  id: String_comparison_exp
  idMemberCreator: String_comparison_exp
  invited: Boolean_comparison_exp
  ixUpdate: String_comparison_exp
  logoHash: String_comparison_exp
  logoUrl: String_comparison_exp
  membersCount: numeric_comparison_exp
  memberships: organizationMemberships_bool_exp
  memberships_aggregate: organizationMemberships_aggregate_bool_exp
  name: String_comparison_exp
  prefs: organizationPrefs_bool_exp
  premiumFeatures: jsonb_comparison_exp
  url: String_comparison_exp
  website: String_comparison_exp
}
"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input organizations_delete_at_path_input {
  premiumFeatures: [String!]
}
"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input organizations_delete_elem_input {
  premiumFeatures: Int
}
"delete key/value pair or string element. key/value pairs are matched based on their key value"
input organizations_delete_key_input {
  premiumFeatures: String
}
"""
input type for incrementing numeric columns in table "organizations"
"""
input organizations_inc_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  membersCount: numeric
}
"""
input type for inserting data into table "organizations"
"""
input organizations_insert_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  boards: boards_arr_rel_insert_input
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  memberships: organizationMemberships_arr_rel_insert_input
  name: String
  prefs: organizationPrefs_obj_rel_insert_input
  premiumFeatures: jsonb
  url: String
  website: String
}
"""
on_conflict condition type for table "organizations"
"""
input organizations_on_conflict {
  constraint: organizations_constraint!
  update_columns: [organizations_update_column!]! = []
  where: organizations_bool_exp
}
"""
Ordering options when selecting data from "organizations".
"""
input organizations_order_by {
  billableCollaboratorCount: order_by
  billableMemberCount: order_by
  boards_aggregate: boards_aggregate_order_by
  creationMethod: order_by
  dateLastActivity: order_by
  desc: order_by
  displayName: order_by
  id: order_by
  idMemberCreator: order_by
  invited: order_by
  ixUpdate: order_by
  logoHash: order_by
  logoUrl: order_by
  membersCount: order_by
  memberships_aggregate: organizationMemberships_aggregate_order_by
  name: order_by
  prefs: organizationPrefs_order_by
  premiumFeatures: order_by
  url: order_by
  website: order_by
}
"primary key columns input for table: organizations"
input organizations_pk_columns_input {
  id: String!
}
"prepend existing jsonb value of filtered columns with new jsonb value"
input organizations_prepend_input {
  premiumFeatures: jsonb
}
"""
input type for updating data in table "organizations"
"""
input organizations_set_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  premiumFeatures: jsonb
  url: String
  website: String
}
"""
Streaming cursor of the table "organizations"
"""
input organizations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: organizations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input organizations_stream_cursor_value_input {
  billableCollaboratorCount: numeric
  billableMemberCount: numeric
  creationMethod: String
  dateLastActivity: timestamptz
  desc: String
  displayName: String
  id: String
  idMemberCreator: String
  invited: Boolean
  ixUpdate: String
  logoHash: String
  logoUrl: String
  membersCount: numeric
  name: String
  premiumFeatures: jsonb
  url: String
  website: String
}
input organizations_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: organizations_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: organizations_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: organizations_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: organizations_delete_key_input
  "increments the numeric columns with given value of the filtered values"
  _inc: organizations_inc_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: organizations_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: organizations_set_input
  "filter the rows which have to be updated"
  where: organizations_bool_exp!
}
input savedSearches_aggregate_bool_exp {
  count: savedSearches_aggregate_bool_exp_count
}
input savedSearches_aggregate_bool_exp_count {
  arguments: [savedSearches_select_column!]
  distinct: Boolean
  filter: savedSearches_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "savedSearches"
"""
input savedSearches_aggregate_order_by {
  count: order_by
  max: savedSearches_max_order_by
  min: savedSearches_min_order_by
}
"""
input type for inserting array relation for remote table "savedSearches"
"""
input savedSearches_arr_rel_insert_input {
  data: [savedSearches_insert_input!]!
  "upsert condition"
  on_conflict: savedSearches_on_conflict
}
"""
Boolean expression to filter rows from the table "savedSearches". All fields are combined with a logical 'AND'.
"""
input savedSearches_bool_exp {
  _and: [savedSearches_bool_exp!]
  _not: savedSearches_bool_exp
  _or: [savedSearches_bool_exp!]
  id: String_comparison_exp
  idMember: String_comparison_exp
  name: String_comparison_exp
  pos: String_comparison_exp
  query: String_comparison_exp
}
"""
input type for inserting data into table "savedSearches"
"""
input savedSearches_insert_input {
  id: String
  idMember: String
  name: String
  pos: String
  query: String
}
"""
order by max() on columns of table "savedSearches"
"""
input savedSearches_max_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  pos: order_by
  query: order_by
}
"""
order by min() on columns of table "savedSearches"
"""
input savedSearches_min_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  pos: order_by
  query: order_by
}
"""
on_conflict condition type for table "savedSearches"
"""
input savedSearches_on_conflict {
  constraint: savedSearches_constraint!
  update_columns: [savedSearches_update_column!]! = []
  where: savedSearches_bool_exp
}
"""
Ordering options when selecting data from "savedSearches".
"""
input savedSearches_order_by {
  id: order_by
  idMember: order_by
  name: order_by
  pos: order_by
  query: order_by
}
"primary key columns input for table: savedSearches"
input savedSearches_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "savedSearches"
"""
input savedSearches_set_input {
  id: String
  idMember: String
  name: String
  pos: String
  query: String
}
"""
Streaming cursor of the table "savedSearches"
"""
input savedSearches_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: savedSearches_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input savedSearches_stream_cursor_value_input {
  id: String
  idMember: String
  name: String
  pos: String
  query: String
}
input savedSearches_updates {
  "sets the columns of the filtered rows to the given values"
  _set: savedSearches_set_input
  "filter the rows which have to be updated"
  where: savedSearches_bool_exp!
}
input sessions_aggregate_bool_exp {
  count: sessions_aggregate_bool_exp_count
}
input sessions_aggregate_bool_exp_count {
  arguments: [sessions_select_column!]
  distinct: Boolean
  filter: sessions_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
}
"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!
  "upsert condition"
  on_conflict: sessions_on_conflict
}
"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  expires: timestamptz_comparison_exp
  id: uuid_comparison_exp
  sessionToken: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}
"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  user: users_obj_rel_insert_input
  userId: uuid
}
"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}
"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}
"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}
"""
Ordering options when selecting data from "sessions".
"""
input sessions_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  user: users_order_by
  userId: order_by
}
"primary key columns input for table: sessions"
input sessions_pk_columns_input {
  id: uuid!
}
"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}
"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sessions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input sessions_stream_cursor_value_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}
input sessions_updates {
  "sets the columns of the filtered rows to the given values"
  _set: sessions_set_input
  "filter the rows which have to be updated"
  where: sessions_bool_exp!
}
input stickers_aggregate_bool_exp {
  count: stickers_aggregate_bool_exp_count
}
input stickers_aggregate_bool_exp_count {
  arguments: [stickers_select_column!]
  distinct: Boolean
  filter: stickers_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "stickers"
"""
input stickers_aggregate_order_by {
  avg: stickers_avg_order_by
  count: order_by
  max: stickers_max_order_by
  min: stickers_min_order_by
  stddev: stickers_stddev_order_by
  stddev_pop: stickers_stddev_pop_order_by
  stddev_samp: stickers_stddev_samp_order_by
  sum: stickers_sum_order_by
  var_pop: stickers_var_pop_order_by
  var_samp: stickers_var_samp_order_by
  variance: stickers_variance_order_by
}
"""
input type for inserting array relation for remote table "stickers"
"""
input stickers_arr_rel_insert_input {
  data: [stickers_insert_input!]!
  "upsert condition"
  on_conflict: stickers_on_conflict
}
"""
order by avg() on columns of table "stickers"
"""
input stickers_avg_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
Boolean expression to filter rows from the table "stickers". All fields are combined with a logical 'AND'.
"""
input stickers_bool_exp {
  _and: [stickers_bool_exp!]
  _not: stickers_bool_exp
  _or: [stickers_bool_exp!]
  id: String_comparison_exp
  idCard: String_comparison_exp
  image: String_comparison_exp
  imageUrl: String_comparison_exp
  left: numeric_comparison_exp
  rotate: numeric_comparison_exp
  top: numeric_comparison_exp
  zIndex: numeric_comparison_exp
}
"""
input type for incrementing numeric columns in table "stickers"
"""
input stickers_inc_input {
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
input type for inserting data into table "stickers"
"""
input stickers_insert_input {
  id: String
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
order by max() on columns of table "stickers"
"""
input stickers_max_order_by {
  id: order_by
  idCard: order_by
  image: order_by
  imageUrl: order_by
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
order by min() on columns of table "stickers"
"""
input stickers_min_order_by {
  id: order_by
  idCard: order_by
  image: order_by
  imageUrl: order_by
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
on_conflict condition type for table "stickers"
"""
input stickers_on_conflict {
  constraint: stickers_constraint!
  update_columns: [stickers_update_column!]! = []
  where: stickers_bool_exp
}
"""
Ordering options when selecting data from "stickers".
"""
input stickers_order_by {
  id: order_by
  idCard: order_by
  image: order_by
  imageUrl: order_by
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"primary key columns input for table: stickers"
input stickers_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "stickers"
"""
input stickers_set_input {
  id: String
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
order by stddev() on columns of table "stickers"
"""
input stickers_stddev_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
order by stddev_pop() on columns of table "stickers"
"""
input stickers_stddev_pop_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
order by stddev_samp() on columns of table "stickers"
"""
input stickers_stddev_samp_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
Streaming cursor of the table "stickers"
"""
input stickers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: stickers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input stickers_stream_cursor_value_input {
  id: String
  idCard: String
  image: String
  imageUrl: String
  left: numeric
  rotate: numeric
  top: numeric
  zIndex: numeric
}
"""
order by sum() on columns of table "stickers"
"""
input stickers_sum_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
input stickers_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: stickers_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: stickers_set_input
  "filter the rows which have to be updated"
  where: stickers_bool_exp!
}
"""
order by var_pop() on columns of table "stickers"
"""
input stickers_var_pop_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
order by var_samp() on columns of table "stickers"
"""
input stickers_var_samp_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
order by variance() on columns of table "stickers"
"""
input stickers_variance_order_by {
  left: order_by
  rotate: order_by
  top: order_by
  zIndex: order_by
}
"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
"""
Boolean expression to filter rows from the table "tokenPermissions". All fields are combined with a logical 'AND'.
"""
input tokenPermissions_bool_exp {
  _and: [tokenPermissions_bool_exp!]
  _not: tokenPermissions_bool_exp
  _or: [tokenPermissions_bool_exp!]
  id: String_comparison_exp
  idModel: String_comparison_exp
  modelType: String_comparison_exp
  read: Boolean_comparison_exp
  write: Boolean_comparison_exp
}
"""
input type for inserting data into table "tokenPermissions"
"""
input tokenPermissions_insert_input {
  id: String
  idModel: String
  modelType: String
  read: Boolean
  write: Boolean
}
"""
input type for inserting object relation for remote table "tokenPermissions"
"""
input tokenPermissions_obj_rel_insert_input {
  data: tokenPermissions_insert_input!
  "upsert condition"
  on_conflict: tokenPermissions_on_conflict
}
"""
on_conflict condition type for table "tokenPermissions"
"""
input tokenPermissions_on_conflict {
  constraint: tokenPermissions_constraint!
  update_columns: [tokenPermissions_update_column!]! = []
  where: tokenPermissions_bool_exp
}
"""
Ordering options when selecting data from "tokenPermissions".
"""
input tokenPermissions_order_by {
  id: order_by
  idModel: order_by
  modelType: order_by
  read: order_by
  write: order_by
}
"primary key columns input for table: tokenPermissions"
input tokenPermissions_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "tokenPermissions"
"""
input tokenPermissions_set_input {
  id: String
  idModel: String
  modelType: String
  read: Boolean
  write: Boolean
}
"""
Streaming cursor of the table "tokenPermissions"
"""
input tokenPermissions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: tokenPermissions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input tokenPermissions_stream_cursor_value_input {
  id: String
  idModel: String
  modelType: String
  read: Boolean
  write: Boolean
}
input tokenPermissions_updates {
  "sets the columns of the filtered rows to the given values"
  _set: tokenPermissions_set_input
  "filter the rows which have to be updated"
  where: tokenPermissions_bool_exp!
}
input tokens_aggregate_bool_exp {
  count: tokens_aggregate_bool_exp_count
}
input tokens_aggregate_bool_exp_count {
  arguments: [tokens_select_column!]
  distinct: Boolean
  filter: tokens_bool_exp
  predicate: Int_comparison_exp!
}
"""
order by aggregate values of table "tokens"
"""
input tokens_aggregate_order_by {
  count: order_by
  max: tokens_max_order_by
  min: tokens_min_order_by
}
"""
input type for inserting array relation for remote table "tokens"
"""
input tokens_arr_rel_insert_input {
  data: [tokens_insert_input!]!
  "upsert condition"
  on_conflict: tokens_on_conflict
}
"""
Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'.
"""
input tokens_bool_exp {
  _and: [tokens_bool_exp!]
  _not: tokens_bool_exp
  _or: [tokens_bool_exp!]
  dateCreated: timestamptz_comparison_exp
  dateExpires: timestamptz_comparison_exp
  id: String_comparison_exp
  idMember: String_comparison_exp
  identifier: String_comparison_exp
  permissions: tokenPermissions_bool_exp
}
"""
input type for inserting data into table "tokens"
"""
input tokens_insert_input {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String
  idMember: String
  identifier: String
  permissions: tokenPermissions_obj_rel_insert_input
}
"""
order by max() on columns of table "tokens"
"""
input tokens_max_order_by {
  dateCreated: order_by
  dateExpires: order_by
  id: order_by
  idMember: order_by
  identifier: order_by
}
"""
order by min() on columns of table "tokens"
"""
input tokens_min_order_by {
  dateCreated: order_by
  dateExpires: order_by
  id: order_by
  idMember: order_by
  identifier: order_by
}
"""
on_conflict condition type for table "tokens"
"""
input tokens_on_conflict {
  constraint: tokens_constraint!
  update_columns: [tokens_update_column!]! = []
  where: tokens_bool_exp
}
"""
Ordering options when selecting data from "tokens".
"""
input tokens_order_by {
  dateCreated: order_by
  dateExpires: order_by
  id: order_by
  idMember: order_by
  identifier: order_by
  permissions: tokenPermissions_order_by
}
"primary key columns input for table: tokens"
input tokens_pk_columns_input {
  id: String!
}
"""
input type for updating data in table "tokens"
"""
input tokens_set_input {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String
  idMember: String
  identifier: String
}
"""
Streaming cursor of the table "tokens"
"""
input tokens_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: tokens_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input tokens_stream_cursor_value_input {
  dateCreated: timestamptz
  dateExpires: timestamptz
  id: String
  idMember: String
  identifier: String
}
input tokens_updates {
  "sets the columns of the filtered rows to the given values"
  _set: tokens_set_input
  "filter the rows which have to be updated"
  where: tokens_bool_exp!
}
"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  accounts: accounts_bool_exp
  accounts_aggregate: accounts_aggregate_bool_exp
  email: String_comparison_exp
  emailVerified: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  name: String_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
}
"""
input type for inserting data into table "users"
"""
input users_insert_input {
  accounts: accounts_arr_rel_insert_input
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  sessions: sessions_arr_rel_insert_input
}
"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  "upsert condition"
  on_conflict: users_on_conflict
}
"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}
"""
Ordering options when selecting data from "users".
"""
input users_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  image: order_by
  name: order_by
  sessions_aggregate: sessions_aggregate_order_by
}
"primary key columns input for table: users"
input users_pk_columns_input {
  id: uuid!
}
"""
input type for updating data in table "users"
"""
input users_set_input {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}
"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: users_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input users_stream_cursor_value_input {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}
input users_updates {
  "sets the columns of the filtered rows to the given values"
  _set: users_set_input
  "filter the rows which have to be updated"
  where: users_bool_exp!
}
"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
"""
Boolean expression to filter rows from the table "verification_tokens". All fields are combined with a logical 'AND'.
"""
input verification_tokens_bool_exp {
  _and: [verification_tokens_bool_exp!]
  _not: verification_tokens_bool_exp
  _or: [verification_tokens_bool_exp!]
  expires: timestamptz_comparison_exp
  identifier: String_comparison_exp
  token: String_comparison_exp
}
"""
input type for inserting data into table "verification_tokens"
"""
input verification_tokens_insert_input {
  expires: timestamptz
  identifier: String
  token: String
}
"""
on_conflict condition type for table "verification_tokens"
"""
input verification_tokens_on_conflict {
  constraint: verification_tokens_constraint!
  update_columns: [verification_tokens_update_column!]! = []
  where: verification_tokens_bool_exp
}
"""
Ordering options when selecting data from "verification_tokens".
"""
input verification_tokens_order_by {
  expires: order_by
  identifier: order_by
  token: order_by
}
"primary key columns input for table: verification_tokens"
input verification_tokens_pk_columns_input {
  token: String!
}
"""
input type for updating data in table "verification_tokens"
"""
input verification_tokens_set_input {
  expires: timestamptz
  identifier: String
  token: String
}
"""
Streaming cursor of the table "verification_tokens"
"""
input verification_tokens_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: verification_tokens_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}
"Initial value of the column from where the streaming should start"
input verification_tokens_stream_cursor_value_input {
  expires: timestamptz
  identifier: String
  token: String
}
input verification_tokens_updates {
  "sets the columns of the filtered rows to the given values"
  _set: verification_tokens_set_input
  "filter the rows which have to be updated"
  where: verification_tokens_bool_exp!
}
"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "measured in seconds"
    ttl: Int! = 60,
    "refresh the cache entry"
    refresh: Boolean! = false
  ) on QUERY
